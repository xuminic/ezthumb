#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <math.h>

#include <iup.h>
#include <iup_config.h>
#include <cd.h>
#include <cdprint.h>
#include <cdiup.h>
#include <im.h>
#include <im_image.h>
#include <im_convert.h>
#include <im_process.h>
#include <iupim.h>
#include <cdim.h>

#if _MSC_VER < 1800 /* vc12 (2013) */
#define DEFINE_ROUND
#endif

#ifdef DEFINE_ROUND
double round(double x)
{
  return (int)(x>0? x+0.5: x-0.5);
}
#endif


/********************************** Images *****************************************/


static Ihandle* load_image_PaintLine(void)
{
  unsigned char imgdata[] = {
    0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    0, 0, 0, 2, 0, 0, 0, 5, 0, 0, 0, 12, 0, 0, 0, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    0, 0, 0, 0, 0, 0, 0, 13, 0, 0, 0, 239, 0, 0, 0, 60, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 84, 0, 0, 0, 239, 0, 0, 0, 60, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 84, 0, 0, 0, 239, 0, 0, 0, 60, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 84, 0, 0, 0, 239, 0, 0, 0, 60, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 84, 0, 0, 0, 239, 0, 0, 0, 60, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 84, 0, 0, 0, 239, 0, 0, 0, 60, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 84, 0, 0, 0, 239, 0, 0, 0, 60, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 84, 0, 0, 0, 239, 0, 0, 0, 60, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 84, 0, 0, 0, 239, 0, 0, 0, 60, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 84, 0, 0, 0, 239, 0, 0, 0, 60, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 84, 0, 0, 0, 239, 0, 0, 0, 60, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 84, 0, 0, 0, 227, 0, 0, 0, 8, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 16, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0 };

  Ihandle* image = IupImageRGBA(16, 16, imgdata);
  IupSetAttribute(image, "AUTOSCALE", "DPI");
  IupSetAttribute(image, "DPI", "96");
  return image;
}

static Ihandle* load_image_Pointer(void)
{
  unsigned char imgdata[] = {
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 162, 180, 203, 255, 162, 180, 203, 84, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 162, 180, 203, 255, 162, 180, 203, 255, 162, 180, 203, 84, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 162, 180, 203, 255, 240, 243, 246, 255, 162, 180, 203, 255, 162, 180, 203, 69, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 162, 180, 203, 255, 255, 255, 255, 255, 241, 244, 247, 255, 161, 179, 202, 255, 161, 179, 202, 57, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 158, 176, 200, 255, 255, 255, 255, 255, 255, 255, 255, 255, 240, 242, 246, 255, 147, 165, 189, 255, 134, 152, 176, 57, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 153, 172, 195, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 227, 231, 236, 255, 129, 147, 171, 255, 115, 134, 158, 48, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 148, 166, 189, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 253, 253, 254, 255, 213, 218, 226, 255, 111, 130, 154, 255, 96, 115, 140, 57, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 141, 159, 183, 255, 254, 255, 255, 255, 252, 253, 254, 255, 250, 251, 253, 255, 247, 248, 251, 255, 243, 246, 250, 255, 206, 213, 223, 255, 91, 110, 136, 255, 73, 92, 118, 48, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 134, 152, 176, 255, 249, 250, 252, 255, 246, 247, 251, 255, 242, 245, 249, 255, 238, 242, 247, 255, 92, 111, 137, 255, 56, 76, 102, 255, 60, 80, 106, 255, 73, 92, 118, 255, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 127, 145, 170, 255, 241, 244, 249, 255, 205, 212, 221, 255, 88, 108, 133, 255, 229, 234, 243, 255, 105, 124, 148, 255, 105, 124, 148, 83, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 119, 138, 163, 255, 203, 209, 220, 255, 63, 83, 109, 255, 102, 121, 145, 255, 197, 206, 221, 255, 187, 197, 214, 255, 89, 108, 133, 255, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 112, 131, 156, 255, 82, 101, 127, 255, 55, 75, 101, 81, 102, 121, 145, 123, 102, 121, 145, 255, 206, 215, 233, 255, 79, 99, 124, 255, 79, 99, 124, 45, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 105, 124, 150, 255, 255, 255, 255, 0, 255, 255, 255, 0, 102, 121, 145, 18, 95, 115, 140, 255, 190, 202, 223, 255, 152, 167, 189, 255, 67, 87, 112, 255, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 95, 115, 140, 150, 84, 104, 129, 255, 164, 178, 202, 255, 58, 78, 104, 255, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 95, 115, 140, 6, 70, 90, 116, 255, 59, 79, 105, 255, 55, 75, 101, 87, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0 };

  Ihandle* image = IupImageRGBA(16, 16, imgdata);
  IupSetAttribute(image, "AUTOSCALE", "DPI");
  IupSetAttribute(image, "DPI", "96");
  return image;
}

static Ihandle* load_image_PaintPencil(void)
{
  unsigned char imgdata[] = {
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 194, 126, 104, 73, 173, 108, 94, 255, 173, 108, 94, 255, 188, 121, 101, 48, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 175, 158, 120, 66, 173, 108, 94, 255, 235, 159, 129, 255, 208, 118, 94, 255, 173, 108, 94, 255, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 175, 158, 120, 66, 187, 176, 125, 255, 172, 184, 202, 255, 209, 133, 115, 255, 173, 108, 94, 255, 144, 53, 53, 255, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 175, 158, 120, 66, 185, 172, 115, 255, 238, 224, 140, 255, 217, 196, 108, 255, 134, 134, 125, 255, 144, 53, 53, 255, 131, 57, 47, 78, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 175, 158, 120, 66, 183, 166, 101, 255, 238, 224, 140, 255, 215, 191, 98, 255, 178, 154, 73, 255, 22, 18, 14, 255, 102, 85, 40, 48, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 175, 158, 120, 66, 185, 172, 115, 255, 238, 224, 140, 255, 215, 191, 98, 255, 178, 154, 73, 255, 22, 18, 14, 255, 117, 98, 45, 59, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 175, 158, 120, 66, 183, 166, 101, 255, 238, 224, 140, 255, 215, 191, 98, 255, 178, 154, 73, 255, 22, 18, 14, 255, 117, 98, 45, 59, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 175, 158, 120, 66, 181, 160, 87, 255, 238, 224, 140, 255, 215, 191, 98, 255, 178, 154, 73, 255, 22, 18, 14, 255, 117, 98, 45, 41, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 175, 158, 120, 66, 179, 156, 77, 255, 238, 224, 140, 255, 215, 191, 98, 255, 178, 154, 73, 255, 22, 18, 14, 255, 117, 98, 45, 41, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 152, 157, 163, 255, 199, 183, 136, 255, 226, 206, 116, 255, 178, 154, 73, 255, 22, 18, 14, 255, 82, 68, 37, 40, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 152, 157, 163, 118, 152, 157, 163, 255, 254, 254, 253, 255, 169, 147, 81, 255, 22, 18, 14, 255, 117, 98, 45, 41, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 118, 110, 113, 117, 255, 81, 84, 87, 255, 0, 0, 0, 255, 82, 68, 37, 40, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 224, 0, 0, 0, 118, 81, 84, 87, 104, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0 };

  Ihandle* image = IupImageRGBA(16, 16, imgdata);
  IupSetAttribute(image, "AUTOSCALE", "DPI");
  IupSetAttribute(image, "DPI", "96");
  return image;
}

static Ihandle* load_image_PaintColorPicker(void)
{
  unsigned char imgdata[] = {
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 1, 1, 1, 85, 0, 0, 1, 192, 0, 0, 0, 192, 0, 0, 0, 85,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 7, 11, 15, 37, 8, 12, 16, 70, 79, 81, 83, 224, 205, 205, 205, 255, 136, 138, 142, 255, 11, 13, 15, 203,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 9, 15, 21, 119, 18, 26, 37, 255, 68, 70, 72, 255, 88, 93, 99, 255, 117, 120, 126, 255, 84, 86, 91, 255, 2, 2, 2, 194,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 15, 21, 30, 31, 23, 34, 49, 235, 49, 56, 65, 255, 70, 72, 72, 255, 54, 56, 58, 255, 21, 22, 22, 199, 0, 0, 0, 85,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 152, 166, 185, 255, 20, 30, 42, 42, 21, 32, 45, 237, 49, 56, 65, 255, 7, 9, 13, 255, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 152, 166, 185, 255, 255, 255, 255, 255, 202, 208, 222, 255, 173, 183, 202, 255, 6, 10, 15, 236, 2, 4, 5, 255, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 152, 166, 185, 255, 255, 255, 255, 255, 202, 208, 222, 255, 143, 156, 181, 255, 68, 88, 114, 255, 1, 1, 3, 33, 0, 0, 0, 111, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 152, 166, 185, 255, 255, 255, 255, 255, 214, 220, 230, 255, 143, 156, 181, 255, 68, 88, 114, 255, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 152, 166, 185, 255, 255, 255, 255, 255, 215, 221, 231, 255, 143, 156, 181, 255, 65, 85, 112, 255, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 152, 166, 185, 255, 255, 255, 255, 255, 216, 220, 231, 255, 143, 156, 181, 255, 65, 85, 112, 255, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 152, 166, 185, 255, 216, 220, 231, 218, 143, 156, 181, 255, 66, 86, 113, 255, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 43, 134, 240, 46, 43, 134, 240, 107, 152, 166, 185, 255, 255, 255, 255, 255, 69, 89, 114, 255, 51, 72, 99, 255, 43, 134, 240, 236, 43, 134, 240, 204, 43, 133, 240, 161, 43, 132, 239, 107, 43, 130, 239, 46, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 43, 133, 239, 170, 43, 133, 240, 255, 87, 105, 130, 255, 79, 97, 123, 255, 43, 134, 240, 255, 43, 134, 240, 255, 43, 135, 240, 255, 43, 134, 240, 255, 43, 134, 240, 255, 43, 134, 240, 255, 43, 133, 239, 170, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 42, 120, 237, 46, 42, 124, 238, 107, 42, 125, 238, 161, 42, 126, 238, 204, 42, 128, 238, 236, 43, 130, 239, 253, 43, 131, 239, 236, 43, 131, 239, 204, 43, 131, 239, 161, 43, 129, 239, 107, 42, 127, 238, 46, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0 };

  Ihandle* image = IupImageRGBA(16, 16, imgdata);
  IupSetAttribute(image, "AUTOSCALE", "DPI");
  IupSetAttribute(image, "DPI", "96");
  return image;
}

static Ihandle* load_image_PaintEllipse(void)
{
  unsigned char imgdata[] = {
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 20, 0, 0, 0, 84, 0, 0, 0, 128, 0, 0, 0, 128, 0, 0, 0, 84, 0, 0, 0, 20, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 16, 0, 0, 0, 155, 0, 0, 0, 239, 0, 0, 0, 175, 0, 0, 0, 131, 0, 0, 0, 131, 0, 0, 0, 175, 0, 0, 0, 239, 0, 0, 0, 155, 0, 0, 0, 16, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 24, 0, 0, 0, 215, 0, 0, 0, 143, 0, 0, 0, 16, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 16, 0, 0, 0, 143, 0, 0, 0, 215, 0, 0, 0, 24, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 199, 0, 0, 0, 120, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 120, 0, 0, 0, 199, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 0, 0, 0, 60, 0, 0, 0, 211, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 211, 0, 0, 0, 60, 255, 255, 255, 0,
    255, 255, 255, 0, 0, 0, 0, 120, 0, 0, 0, 139, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 139, 0, 0, 0, 120, 255, 255, 255, 0,
    255, 255, 255, 0, 0, 0, 0, 120, 0, 0, 0, 135, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 135, 0, 0, 0, 120, 255, 255, 255, 0,
    255, 255, 255, 0, 0, 0, 0, 68, 0, 0, 0, 211, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 211, 0, 0, 0, 68, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 199, 0, 0, 0, 120, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 120, 0, 0, 0, 199, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 36, 0, 0, 0, 231, 0, 0, 0, 135, 0, 0, 0, 12, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 12, 0, 0, 0, 135, 0, 0, 0, 231, 0, 0, 0, 36, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 20, 0, 0, 0, 163, 0, 0, 0, 239, 0, 0, 0, 171, 0, 0, 0, 131, 0, 0, 0, 131, 0, 0, 0, 171, 0, 0, 0, 239, 0, 0, 0, 163, 0, 0, 0, 20, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 24, 0, 0, 0, 88, 0, 0, 0, 128, 0, 0, 0, 128, 0, 0, 0, 88, 0, 0, 0, 24, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0 };

  Ihandle* image = IupImageRGBA(16, 16, imgdata);
  IupSetAttribute(image, "AUTOSCALE", "DPI");
  IupSetAttribute(image, "DPI", "96");
  return image;
}

static Ihandle* load_image_PaintRect(void)
{
  unsigned char imgdata[] = {
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 254, 0, 0, 0, 247, 0, 0, 0, 239, 0, 0, 0, 247, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 255, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 255, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 255, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 255, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 255, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 255, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 255, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 255, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 255, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 255, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 255, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 255, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 255, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 255, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 255, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 255, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0 };

  Ihandle* image = IupImageRGBA(16, 16, imgdata);
  IupSetAttribute(image, "AUTOSCALE", "DPI");
  IupSetAttribute(image, "DPI", "96");
  return image;
}

static Ihandle* load_image_PaintOval(void)
{
  unsigned char imgdata[] = {
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 24, 0, 0, 0, 135, 0, 0, 0, 211, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 211, 0, 0, 0, 135, 0, 0, 0, 24, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 80, 0, 0, 0, 239, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 239, 0, 0, 0, 80, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 48, 0, 0, 0, 251, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 251, 0, 0, 0, 48, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 183, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 183, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 247, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 247, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 247, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 247, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 183, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 183, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 56, 0, 0, 0, 251, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 251, 0, 0, 0, 56, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 84, 0, 0, 0, 243, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 243, 0, 0, 0, 84, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 24, 0, 0, 0, 139, 0, 0, 0, 211, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 211, 0, 0, 0, 139, 0, 0, 0, 24, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0 };

  Ihandle* image = IupImageRGBA(16, 16, imgdata);
  IupSetAttribute(image, "AUTOSCALE", "DPI");
  IupSetAttribute(image, "DPI", "96");
  return image;
}

static Ihandle* load_image_PaintBox(void)
{
  unsigned char imgdata[] = {
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 254, 0, 0, 0, 247, 0, 0, 0, 239, 0, 0, 0, 247, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0 };

  Ihandle* image = IupImageRGBA(16, 16, imgdata);
  IupSetAttribute(image, "AUTOSCALE", "DPI");
  IupSetAttribute(image, "DPI", "96");
  return image;
}

static Ihandle* load_image_PaintZoomGrid(void)
{
  unsigned char imgdata[] = {
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 110, 155, 223, 255, 255, 255, 255, 0, 255, 255, 255, 0, 106, 151, 219, 255, 255, 255, 255, 0, 255, 255, 255, 0, 95, 142, 210, 255, 255, 255, 255, 0, 255, 255, 255, 0, 84, 129, 201, 255, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 110, 155, 223, 255, 255, 255, 255, 0, 255, 255, 255, 0, 102, 147, 217, 255, 255, 255, 255, 0, 255, 255, 255, 0, 92, 137, 207, 255, 255, 255, 255, 0, 255, 255, 255, 0, 80, 125, 197, 255, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 110, 155, 223, 255, 110, 155, 223, 255, 107, 152, 222, 255, 104, 151, 219, 255, 103, 148, 216, 255, 100, 145, 213, 255, 97, 142, 210, 255, 93, 138, 206, 255, 88, 133, 203, 255, 84, 129, 201, 255, 80, 125, 197, 255, 76, 121, 193, 255, 72, 117, 189, 255, 68, 113, 183, 255, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 106, 149, 219, 255, 255, 255, 255, 0, 255, 255, 255, 0, 97, 142, 210, 255, 255, 255, 255, 0, 255, 255, 255, 0, 84, 131, 199, 255, 255, 255, 255, 0, 255, 255, 255, 0, 72, 117, 187, 255, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 103, 148, 216, 255, 255, 255, 255, 0, 255, 255, 255, 0, 92, 137, 207, 255, 255, 255, 255, 0, 255, 255, 255, 0, 81, 125, 196, 255, 255, 255, 255, 0, 255, 255, 255, 0, 68, 113, 185, 255, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 104, 151, 219, 255, 104, 148, 216, 255, 100, 145, 213, 255, 97, 142, 210, 255, 92, 137, 207, 255, 88, 135, 203, 255, 84, 129, 199, 255, 80, 125, 195, 255, 76, 121, 193, 255, 70, 117, 189, 255, 68, 112, 183, 255, 62, 109, 181, 255, 60, 105, 177, 255, 57, 102, 174, 255, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 97, 142, 210, 255, 255, 255, 255, 0, 255, 255, 255, 0, 84, 129, 199, 255, 255, 255, 255, 0, 255, 255, 255, 0, 72, 117, 187, 255, 255, 255, 255, 0, 255, 255, 255, 0, 60, 105, 177, 255, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 93, 138, 206, 255, 255, 255, 255, 0, 255, 255, 255, 0, 80, 125, 195, 255, 255, 255, 255, 0, 255, 255, 255, 0, 66, 113, 185, 255, 255, 255, 255, 0, 255, 255, 255, 0, 56, 103, 173, 255, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 95, 140, 212, 255, 92, 137, 207, 255, 88, 133, 203, 255, 84, 129, 199, 255, 80, 125, 195, 255, 76, 121, 193, 255, 72, 117, 187, 255, 68, 113, 185, 255, 64, 107, 181, 255, 59, 105, 178, 255, 55, 101, 174, 255, 53, 98, 170, 255, 49, 95, 168, 255, 48, 91, 165, 255, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 84, 131, 199, 255, 255, 255, 255, 0, 255, 255, 255, 0, 70, 117, 189, 255, 255, 255, 255, 0, 255, 255, 255, 0, 60, 105, 177, 255, 255, 255, 255, 0, 255, 255, 255, 0, 49, 95, 168, 255, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 82, 125, 195, 255, 255, 255, 255, 0, 255, 255, 255, 0, 68, 113, 185, 255, 255, 255, 255, 0, 255, 255, 255, 0, 57, 102, 174, 255, 255, 255, 255, 0, 255, 255, 255, 0, 46, 92, 165, 255, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 84, 129, 199, 255, 80, 125, 195, 255, 76, 121, 191, 255, 72, 117, 189, 255, 66, 113, 185, 255, 64, 109, 181, 255, 60, 105, 177, 255, 55, 102, 174, 255, 52, 98, 171, 255, 49, 95, 168, 255, 46, 91, 166, 255, 44, 90, 163, 255, 42, 88, 161, 255, 42, 88, 161, 255, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 72, 117, 187, 255, 255, 255, 255, 0, 255, 255, 255, 0, 60, 107, 177, 255, 255, 255, 255, 0, 255, 255, 255, 0, 50, 95, 167, 255, 255, 255, 255, 0, 255, 255, 255, 0, 42, 88, 161, 255, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 68, 113, 185, 255, 255, 255, 255, 0, 255, 255, 255, 0, 56, 101, 173, 255, 255, 255, 255, 0, 255, 255, 255, 0, 46, 92, 165, 255, 255, 255, 255, 0, 255, 255, 255, 0, 42, 88, 161, 255, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0 };

  Ihandle* image = IupImageRGBA(16, 16, imgdata);
  IupSetAttribute(image, "AUTOSCALE", "DPI");
  IupSetAttribute(image, "DPI", "96");
  return image;
}

static Ihandle* load_image_PaintFill(void)
{
  unsigned char imgdata[] = {
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 50, 53, 53, 86, 59, 59, 59, 111, 108, 108, 108, 82, 127, 127, 127, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 52, 54, 54, 122, 72, 72, 72, 7, 119, 122, 124, 117, 124, 124, 130, 47, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 77, 77, 76, 154, 144, 166, 188, 23, 158, 169, 181, 191, 144, 151, 159, 194, 134, 147, 174, 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 124, 126, 129, 197, 141, 160, 183, 179, 212, 219, 225, 254, 157, 162, 166, 254, 163, 180, 200, 168, 159, 175, 191, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 130, 141, 158, 45, 130, 143, 155, 245, 218, 225, 232, 250, 222, 232, 239, 255, 136, 139, 142, 255, 205, 217, 227, 252, 148, 167, 189, 163, 155, 155, 184, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 148, 170, 24, 134, 155, 174, 172, 213, 220, 227, 254, 218, 233, 243, 255, 197, 207, 217, 255, 149, 149, 150, 255, 232, 241, 245, 255, 179, 196, 213, 252, 129, 147, 172, 164, 75, 103, 144, 37, 17, 51, 102, 15, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 134, 147, 174, 19, 122, 146, 168, 179, 216, 223, 228, 252, 217, 231, 242, 255, 213, 227, 238, 255, 159, 162, 164, 255, 128, 129, 128, 255, 228, 235, 239, 255, 171, 197, 218, 255, 136, 162, 190, 253, 87, 116, 156, 227, 37, 75, 150, 183, 0, 31, 107, 57, 0, 0, 0, 0,
    0, 0, 0, 0, 120, 134, 161, 19, 126, 147, 168, 157, 209, 217, 225, 245, 217, 231, 241, 255, 203, 217, 232, 255, 242, 244, 245, 255, 192, 192, 191, 255, 164, 166, 169, 255, 202, 213, 223, 255, 158, 176, 194, 255, 126, 154, 184, 255, 103, 134, 168, 255, 76, 110, 169, 255, 49, 93, 175, 201, 37, 66, 132, 27,
    122, 132, 160, 27, 102, 124, 149, 172, 194, 209, 220, 241, 213, 228, 239, 246, 204, 218, 232, 249, 241, 242, 244, 255, 247, 245, 245, 255, 243, 244, 243, 255, 222, 228, 234, 255, 192, 203, 214, 255, 159, 172, 185, 255, 138, 152, 168, 255, 84, 116, 151, 248, 74, 104, 158, 246, 83, 129, 213, 243, 77, 108, 169, 92,
    125, 134, 152, 55, 111, 131, 154, 211, 189, 201, 214, 255, 214, 223, 234, 254, 238, 240, 243, 236, 248, 246, 245, 241, 242, 243, 243, 254, 221, 228, 234, 255, 192, 203, 214, 255, 165, 178, 192, 255, 142, 155, 169, 255, 98, 117, 137, 243, 77, 94, 120, 121, 46, 82, 158, 171, 87, 131, 209, 247, 85, 114, 171, 122,
    0, 255, 255, 1, 134, 140, 167, 38, 137, 155, 179, 206, 218, 223, 230, 254, 244, 242, 243, 252, 242, 244, 243, 239, 220, 228, 234, 252, 192, 202, 214, 255, 164, 176, 190, 255, 140, 154, 168, 255, 92, 112, 132, 243, 75, 91, 114, 111, 102, 102, 153, 5, 29, 61, 136, 140, 68, 109, 192, 244, 84, 113, 170, 94,
    0, 0, 0, 0, 0, 0, 255, 1, 157, 173, 195, 47, 148, 166, 191, 205, 204, 210, 220, 248, 227, 231, 235, 253, 193, 204, 216, 255, 163, 175, 189, 255, 138, 151, 166, 255, 95, 113, 134, 242, 74, 88, 113, 110, 95, 127, 127, 8, 0, 0, 0, 0, 35, 66, 135, 145, 72, 109, 182, 239, 91, 120, 178, 53,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 142, 165, 34, 103, 124, 151, 197, 158, 172, 187, 252, 164, 176, 189, 255, 134, 148, 162, 254, 96, 113, 133, 245, 75, 87, 110, 122, 102, 102, 102, 5, 0, 0, 0, 0, 0, 0, 0, 0, 60, 91, 151, 173, 84, 115, 173, 195, 98, 117, 176, 13,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 102, 110, 119, 30, 73, 96, 120, 204, 107, 126, 144, 255, 106, 123, 141, 255, 102, 115, 135, 152, 139, 150, 162, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 92, 154, 173, 85, 115, 173, 119, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 49, 82, 115, 31, 49, 79, 109, 212, 92, 110, 134, 169, 143, 159, 175, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 65, 93, 154, 163, 63, 89, 153, 20, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 109, 118, 140, 58, 85, 106, 148, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 61, 92, 154, 33, 0, 0, 0, 0, 0, 0, 0, 0 };

  Ihandle* image = IupImageRGBA(16, 16, imgdata);
  IupSetAttribute(image, "AUTOSCALE", "DPI");
  IupSetAttribute(image, "DPI", "96");
  return image;
}

static Ihandle* load_image_PaintText(void)
{
  unsigned char imgdata[] = {
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 36, 0, 0, 0, 96, 0, 0, 0, 96, 0, 0, 0, 96, 0, 0, 0, 96, 0, 0, 0, 96, 0, 0, 0, 96, 0, 0, 0, 96, 0, 0, 0, 96, 0, 0, 0, 96, 0, 0, 0, 96, 0, 0, 0, 72, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 96, 0, 0, 0, 255, 0, 0, 0, 203, 0, 0, 0, 124, 0, 0, 0, 135, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 215, 0, 0, 0, 96, 0, 0, 0, 131, 0, 0, 0, 243, 0, 0, 0, 191, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 96, 0, 0, 0, 163, 255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 64, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 191, 255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 44, 0, 0, 0, 191, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 96, 0, 0, 0, 48, 255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 64, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 191, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 116, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 64, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 191, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 64, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 191, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 64, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 191, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 64, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 191, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 64, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 191, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 64, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 191, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 64, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 191, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 64, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 191, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 0, 0, 0, 96, 0, 0, 0, 187, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 243, 0, 0, 0, 116, 0, 0, 0, 48, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0,
    255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0 };

  Ihandle* image = IupImageRGBA(16, 16, imgdata);
  IupSetAttribute(image, "AUTOSCALE", "DPI");
  IupSetAttribute(image, "DPI", "96");
  return image;
}


/********************************** Utilities *****************************************/


static const char* str_fileext(const char *filename)
{
  /* Start at the last character */
  int len = (int)strlen(filename);
  int offset = len - 1;
  while (offset != 0)
  {
    if (filename[offset] == '\\' || filename[offset] == '/')
      break;

    if (filename[offset] == '.')
    {
      offset++;
      return filename + offset;
    }
    offset--;
  }
  return NULL;
}

static int str_compare(const char *l, const char *r, int casesensitive)
{
  if (!l || !r)
    return 0;

  while (*l && *r)
  {
    int diff;
    char l_char = *l,
      r_char = *r;

    /* compute the difference of both characters */
    if (casesensitive)
      diff = l_char - r_char;
    else
      diff = tolower((int)l_char) - tolower((int)r_char);

    /* if they differ we have a result */
    if (diff != 0)
      return 0;

    /* otherwise process the next characters */
    ++l;
    ++r;
  }

  /* check also for terminator */
  if (*l == *r)
    return 1;

  if (*r == 0)
    return 1;  /* if second string is at terminator, then it is partially equal */

  return 0;
}

static void show_error(const char* message, int is_error)
{
  Ihandle* dlg = IupMessageDlg();
  IupSetStrAttribute(dlg, "PARENTDIALOG", IupGetGlobal("PARENTDIALOG"));
  IupSetAttribute(dlg, "DIALOGTYPE", is_error ? "ERROR" : "WARNING");
  IupSetAttribute(dlg, "BUTTONS", "OK");
  IupSetStrAttribute(dlg, "TITLE", is_error ? "Error" : "Warning");
  IupSetStrAttribute(dlg, "VALUE", message);
  IupPopup(dlg, IUP_CENTERPARENT, IUP_CENTERPARENT);
  IupDestroy(dlg);
}

static void show_file_error(int error)
{
  switch (error)
  {
  case IM_ERR_OPEN:
    show_error("Error Opening File.",  1);
    break;
  case IM_ERR_MEM:
    show_error("Insufficient memory.",  1);
    break;
  case IM_ERR_ACCESS:
    show_error("Error Accessing File.",  1);
    break;
  case IM_ERR_DATA:
    show_error("Image type not Supported.",  1);
    break;
  case IM_ERR_FORMAT:
    show_error("Invalid Format.",  1);
    break;
  case IM_ERR_COMPRESS:
    show_error("Invalid or unsupported compression.",  1);
    break;
  default:
    show_error("Unknown Error.",  1);
  }
}

static imImage* read_file(const char* filename)
{
  int error;
  imImage* image = imFileImageLoadBitmap(filename, 0, &error);
  if (error) 
    show_file_error(error);
  return image;
}

static int write_file(const char* filename, const imImage* image)
{
  const char* format = imImageGetAttribString(image, "FileFormat");
  int error = imFileImageSave(filename, format, image);
  if (error)
  {
    show_file_error(error);
    return 0;
  }
  return 1;
}

/* extracted from the SCROLLBAR attribute documentation */
static void scroll_update(Ihandle* ih, int view_width, int view_height)
{
  /* view_width and view_height is the virtual space size */
  /* here we assume XMIN=0, XMAX=1, YMIN=0, YMAX=1 */
  int elem_width, elem_height;
  int canvas_width, canvas_height;
  int scrollbar_size = IupGetInt(NULL, "SCROLLBARSIZE");
  int border = IupGetInt(ih, "BORDER");

  IupGetIntInt(ih, "RASTERSIZE", &elem_width, &elem_height);

  /* if view is greater than canvas in one direction,
  then it has scrollbars,
  but this affects the opposite direction */
  elem_width -= 2 * border;  /* remove BORDER (always size=1) */
  elem_height -= 2 * border;
  canvas_width = elem_width;
  canvas_height = elem_height;
  if (view_width > elem_width)  /* check for horizontal scrollbar */
    canvas_height -= scrollbar_size;  /* affect vertical size */
  if (view_height > elem_height)
    canvas_width -= scrollbar_size;
  if (view_width <= elem_width && view_width > canvas_width)  /* check if still has horizontal scrollbar */
    canvas_height -= scrollbar_size;
  if (view_height <= elem_height && view_height > canvas_height)
    canvas_width -= scrollbar_size;
  if (canvas_width < 0) canvas_width = 0;
  if (canvas_height < 0) canvas_height = 0;

  IupSetFloat(ih, "DX", (float)canvas_width / (float)view_width);
  IupSetFloat(ih, "DY", (float)canvas_height / (float)view_height);
}

static void scroll_calc_center(Ihandle* ih, float *x, float *y)
{
  *x = IupGetFloat(ih, "POSX") + IupGetFloat(ih, "DX") / 2.0f;
  *y = IupGetFloat(ih, "POSY") + IupGetFloat(ih, "DY") / 2.0f;
}

static void scroll_center(Ihandle* ih, float old_center_x, float old_center_y)
{
  /* always update the scroll position
     keeping it proportional to the old position
     relative to the center of the ih. */

  float dx = IupGetFloat(ih, "DX");
  float dy = IupGetFloat(ih, "DY");

  float posx = old_center_x - dx / 2.0f;
  float posy = old_center_y - dy / 2.0f;

  if (posx < 0) posx = 0;
  if (posx > 1 - dx) posx = 1 - dx;

  if (posy < 0) posy = 0;
  if (posy > 1 - dy) posy = 1 - dy;

  IupSetFloat(ih, "POSX", posx);
  IupSetFloat(ih, "POSY", posy);
}

static void scroll_move(Ihandle* ih, int canvas_width, int canvas_height, int move_x, int move_y, int view_width, int view_height)
{
  float posy = 0;
  float posx = 0;

  if (move_x == 0 && move_y == 0)
    return;

  if (canvas_height < view_height)
  {
    posy = IupGetFloat(ih, "POSY");
    posy -= (float)move_y / (float)view_height;
  }

  if (canvas_width < view_width)
  {
    posx = IupGetFloat(ih, "POSX");
    posx -= (float)move_x / (float)view_width;
  }

  if (posx != 0 || posy != 0)
  {
    IupSetFloat(ih, "POSX", posx);
    IupSetFloat(ih, "POSY", posy);
    IupRedraw(ih, 0);
  }
}

static void zoom_update(Ihandle* ih, double zoom_index)
{
  Ihandle* zoom_lbl = IupGetDialogChild(ih, "ZOOMLABEL");
  Ihandle* canvas = IupGetDialogChild(ih, "CANVAS");
  imImage* image = (imImage*)IupGetAttribute(canvas, "IMAGE");
  double zoom_factor = pow(2, zoom_index);
  IupSetStrf(zoom_lbl, "TITLE", "%.0f%%", floor(zoom_factor * 100));
  if (image)
  {
    float old_center_x, old_center_y;
    int view_width = (int)(zoom_factor * image->width);
    int view_height = (int)(zoom_factor * image->height);

    scroll_calc_center(canvas, &old_center_x, &old_center_y);

    scroll_update(canvas, view_width, view_height);

    scroll_center(canvas, old_center_x, old_center_y);
  }
  IupUpdate(canvas);
}

static void image_flood_fill(imImage* image, int start_x, int start_y, long replace_color, int replace_index, double tol_percent)
{
  double color[4];
  double tol;

  if (image->color_space == IM_RGB)
  {
    color[0] = (double)cdRed(replace_color);
    color[1] = (double)cdGreen(replace_color);
    color[2] = (double)cdBlue(replace_color);
    color[3] = (double)cdAlpha(replace_color);
  }
  else
  {
    color[0] = (double)replace_index;
    color[1] = 0;
    color[2] = 0;
    color[3] = 0;
  }

  /* max value = 255*255*3 = 195075 */
  /* sqrt(195075) = 441 */
  tol = (441 * tol_percent) / 100;

  /* still too high */
  tol = tol / 5;  /* empirical reduce. TODO: What is the best formula? */

  imProcessRenderFloodFill(image, start_x, start_y, color, tol);
}

static void image_fill_white(imImage* image)
{
  double color[4];

  color[0] = 255;  /* white also for GRAY and new MAP */
  color[1] = 255;
  color[2] = 255;
  color[3] = 255;  /* opaque */

  imProcessRenderConstant(image, color);
}

static void update_toolbox(Ihandle* toolbox, int map)
{
  Ihandle* tool_pointer = IupGetDialogChild(toolbox, "TOOL_POINTER");
  Ihandle* tool = IupGetBrother(IupGetBrother(IupGetBrother(tool_pointer)));
  const char* value = "Yes";
  if (map)
    value = "No";

  IupSetAttribute(tool, "ACTIVE", value); tool = IupGetBrother(tool);  /* TOOLINDEX=3 */
  IupSetAttribute(tool, "ACTIVE", value); tool = IupGetBrother(tool);  /* TOOLINDEX=4 */
  IupSetAttribute(tool, "ACTIVE", value); tool = IupGetBrother(tool);  /* TOOLINDEX=5 */
  IupSetAttribute(tool, "ACTIVE", value); tool = IupGetBrother(tool);  /* TOOLINDEX=6 */
  IupSetAttribute(tool, "ACTIVE", value); tool = IupGetBrother(tool);  /* TOOLINDEX=7 */
  IupSetAttribute(tool, "ACTIVE", value); tool = IupGetBrother(tool);  /* TOOLINDEX=8 */
}

static void update_title(Ihandle* canvas)
{
  Ihandle* dlg = IupGetDialog(canvas);
  char* name = IupGetAttribute(canvas, "IUP_IMAGE_NAME");
  int dirty = IupGetInt(canvas, "DIRTY");
  IupSetfAttribute(dlg, "TITLE", "ImageEditor - %s%s", name, dirty? " *": "");
}

static void update_image(Ihandle* canvas, imImage* image, int update_size)
{
  Ihandle* toolbox = IupGetDialogChild(canvas, "TOOLBOX");
  imImage* old_image = (imImage*)IupGetAttribute(canvas, "IMAGE");

  IupSetAttribute(canvas, "IMAGE", (char*)image);
  IupSetAttribute(canvas, "DIRTY", "Yes");
  update_title(canvas);

  if (old_image)
    imImageDestroy(old_image);

  if (image->color_space == IM_MAP || image->color_space == IM_GRAY)
  {
    /* reset the color selection to match the new palette */
    Ihandle* color = IupGetDialogChild(toolbox, "COLOR");
    unsigned char r, g, b, a = 255;
    long c = image->palette[0];
    r = cdRed(c);
    g = cdGreen(c);
    b = cdBlue(c);
    IupSetInt(toolbox, "TOOLCOLORINDEX", 0);
    IupSetRGB(color, "BGCOLOR", r, g, b);
    IupSetRGBA(toolbox, "TOOLCOLOR", r, g, b, a);
  }

  update_toolbox(toolbox, image->color_space == IM_MAP || image->color_space == IM_GRAY);

  if (update_size)
  {
    Ihandle* size_lbl = IupGetDialogChild(canvas, "SIZELABEL");
    Ihandle* zoom_val = IupGetDialogChild(canvas, "ZOOMVAL");
    double zoom_index = IupGetDouble(zoom_val, "VALUE");
    IupSetfAttribute(size_lbl, "TITLE", "%d x %d px", image->width, image->height);
    zoom_update(canvas, zoom_index);
  }
  else
    IupUpdate(canvas);
}

static void imImageViewFitRect(int Width, int Height, int wi, int hi, int *w, int *h)
{
  double rView, rImage;
  int correct = 0;

  *w = Width;
  *h = Height;

  rView = ((double)Height) / Width;
  rImage = ((double)hi) / wi;

  if ((rView <= 1 && rImage <= 1) || (rView >= 1 && rImage >= 1)) /* view and image are horizontal rectangles */
  {
    if (rView > rImage)
      correct = 2;
    else
      correct = 1;
  }
  else if (rView < 1 && rImage > 1) /* view is a horizontal rectangle and image is a vertical rectangle */
    correct = 1;
  else if (rView > 1 && rImage < 1) /* view is a vertical rectangle and image is a horizontal rectangle */
    correct = 2;

  if (correct == 1)
    *w = (int)(Height / rImage);
  else if (correct == 2)
    *h = (int)(Width * rImage);
}

static void fit_zoom(Ihandle* canvas, imImage* image, Ihandle* zoom_val)
{
  int canvas_width = 0, canvas_height = 0, view_width, view_height;
  double zoom_index, zoom_factor;

  IupGetIntInt(canvas, "DRAWSIZE", &canvas_width, &canvas_height);

  imImageViewFitRect(canvas_width, canvas_height, image->width, image->height, &view_width, &view_height);

  zoom_factor = (double)view_width / image->width;
  zoom_index = log(zoom_factor) / log(2.0);

  if (zoom_index < -6)
    zoom_index = -6;
  if (zoom_index > 6)
    zoom_index = 6;

  IupSetDouble(zoom_val, "VALUE", zoom_index);
}

static void set_new_image(Ihandle* canvas, imImage* image, int dirty)
{
  Ihandle* zoom_val = IupGetDialogChild(canvas, "ZOOMVAL");
  const char* format;

  /* we are going to support only RGB and MAP images */
  if (image->color_space != IM_RGB && image->color_space != IM_MAP && image->color_space != IM_GRAY)
  {
    imImage* new_image = imImageCreateBased(image, -1, -1, IM_RGB, -1);
    if (image->has_alpha)
    {
      imImageAddAlpha(new_image);
      imImageSetAlpha(image, 255); /* opaque */
    }
    imConvertColorSpace(image, new_image);
    imImageDestroy(image);

    image = new_image;
  }

  if (image->color_space == IM_MAP || image->color_space == IM_GRAY)
  {
    const unsigned char* transp_index = imImageGetAttribute(image, "TransparencyIndex", NULL, NULL);
    if (transp_index)
    {
      int index = (int)(*transp_index);
      unsigned int ri, gi, bi;
      Ihandle* config = (Ihandle*)IupGetAttribute(canvas, "CONFIG");
      const char* background = IupConfigGetVariableStrDef(config, "ImageEditor", "Background", "208 208 208");
      sscanf(background, "%u %u %u", &ri, &gi, &bi);

      image->palette[index] = cdEncodeColor((unsigned char)ri, (unsigned char)gi, (unsigned char)bi);
    }
  }

  /* default file format */
  format = imImageGetAttribString(image, "FileFormat");
  if (!format)
    imImageSetAttribString(image, "FileFormat", "PNG");

  fit_zoom(canvas, image, zoom_val);

  update_image(canvas, image, 1);

  IupSetAttribute(canvas, "DIRTY", dirty ? "Yes" : "No");
  update_title(canvas);
}

static void import_file(Ihandle* ih, const char* filename)
{
  imImage* image = read_file(filename);
  if (image)
  {
    Ihandle* canvas = IupGetDialogChild(ih, "CANVAS");
    set_new_image(canvas, image, 1);  /* set dirty */
  }
}

static void save_iup_image(Ihandle* canvas)
{
  char* name = IupGetAttribute(canvas, "IUP_IMAGE_NAME");
  char* filename = IupGetAttribute(canvas, "_IUPLED_FILENAME");
  imImage* image = (imImage*)IupGetAttribute(canvas, "IMAGE");
  Ihandle* old_iup_image = IupGetHandle(name);
  Icallback imagechanged_cb = IupGetCallback(IupGetDialog(canvas), "IMAGECHANGED_CB");

  Ihandle* iup_image = IupImageFromImImage(image);
  if (!iup_image)
  {
    show_file_error(IM_ERR_MEM);
    return;
  }

  if (old_iup_image)
    IupDestroy(old_iup_image);

  IupSetHandle(name, iup_image);
  IupSetStrAttribute(iup_image, "_IUPLED_FILENAME", filename);

  IupSetAttribute(canvas, "DIRTY", "NO");
  update_title(canvas);

  if (imagechanged_cb)
    imagechanged_cb(IupGetDialog(canvas));
}

static void set_file_format(imImage* image, const char* filename)
{
  const char* ext = str_fileext(filename);
  const char* format = "PNG";
  if (str_compare(ext, "jpg", 0) || str_compare(ext, "jpeg", 0))
    format = "JPEG";
  else if (str_compare(ext, "bmp", 0))
    format = "BMP";
  else if (str_compare(ext, "gif", 0))
    format = "GIF";
  else if (str_compare(ext, "png", 0))
    format = "PNG";
  else if (str_compare(ext, "tga", 0))
    format = "TGA";
  else if (str_compare(ext, "tif", 0) || str_compare(ext, "tiff", 0))
    format = "TIFF";
  imImageSetAttribString(image, "FileFormat", format);
}

static void export_file(Ihandle* canvas, const char* filename)
{
  imImage* image = (imImage*)IupGetAttribute(canvas, "IMAGE");
  set_file_format(image, filename);
  write_file(filename, image);
}

static int save_check(Ihandle* ih)
{
  Ihandle* canvas = IupGetDialogChild(ih, "CANVAS");
  if (IupGetInt(canvas, "DIRTY"))
  {
    switch (IupAlarm("Warning", "Image not saved! Save it now?", "Yes", "No", "Cancel"))
    {
    case 1:  /* save the changes and continue */
      save_iup_image(canvas);
      break;
    case 2:  /* ignore the changes and continue */
      break;
    case 3:  /* cancel */
      return 0;  
    }
  }
  return 1;
}

static void toggle_bar_visibility(Ihandle* item, Ihandle* ih)
{
  if (IupGetInt(item, "VALUE"))
  {
    IupSetAttribute(ih, "FLOATING", "YES");
    IupSetAttribute(ih, "VISIBLE", "NO");
    IupSetAttribute(item, "VALUE", "OFF");
  }
  else
  {
    IupSetAttribute(ih, "FLOATING", "NO");
    IupSetAttribute(ih, "VISIBLE", "YES");
    IupSetAttribute(item, "VALUE", "ON");
  }

  IupRefresh(ih);  /* refresh the dialog layout */
}

static int select_file(Ihandle* parent_dlg, int is_open)
{
  Ihandle* config = (Ihandle*)IupGetAttribute(parent_dlg, "CONFIG");
  Ihandle* canvas = IupGetDialogChild(parent_dlg, "CANVAS");
  const char* dir = IupConfigGetVariableStr(config, "ImageEditor", "LastDirectory");

  Ihandle* filedlg = IupFileDlg();
  if (is_open)
    IupSetAttribute(filedlg, "DIALOGTYPE", "OPEN");
  else
  {
    IupSetAttribute(filedlg, "DIALOGTYPE", "SAVE");
    IupSetStrAttribute(filedlg, "FILE", IupGetAttribute(canvas, "_IUP_IMAGE_HANDLE"));
  }
  IupSetAttribute(filedlg, "EXTFILTER", "Image Files|*.bmp;*.gif;*.jpg;*.png;*.tif;*.tga|All Files|*.*|");
  IupSetStrAttribute(filedlg, "DIRECTORY", dir);
  IupSetAttributeHandle(filedlg, "PARENTDIALOG", parent_dlg);

  IupPopup(filedlg, IUP_CENTERPARENT, IUP_CENTERPARENT);
  if (IupGetInt(filedlg, "STATUS") != -1)
  {
    char* filename = IupGetAttribute(filedlg, "VALUE");
    if (is_open)
      import_file(parent_dlg, filename);
    else
      export_file(canvas, filename);

    dir = IupGetAttribute(filedlg, "DIRECTORY");
    IupConfigSetVariableStr(config, "ImageEditor", "LastDirectory", dir);
  }

  IupDestroy(filedlg);
  return IUP_DEFAULT;
}

static void view_fit_rect(int canvas_width, int canvas_height, int image_width, int image_height, int *view_width, int *view_height)
{
  *view_width = canvas_width;
  *view_height = (canvas_width * image_height) / image_width;

  if (*view_height > canvas_height)
  {
    *view_height = canvas_height;
    *view_width = (canvas_height * image_width) / image_height;
  }
}

static double view_zoom_rect(Ihandle* ih, int image_width, int image_height, int *_x, int *_y, int *_view_width, int *_view_height)
{
  int x, y, canvas_width, canvas_height;
  int view_width, view_height;
  Ihandle* zoom_val = IupGetDialogChild(ih, "ZOOMVAL");
  double zoom_index = IupGetDouble(zoom_val, "VALUE");
  double zoom_factor = pow(2, zoom_index);

  float posy = IupGetFloat(ih, "POSY");
  float posx = IupGetFloat(ih, "POSX");

  IupGetIntInt(ih, "DRAWSIZE", &canvas_width, &canvas_height);

  view_width = (int)(zoom_factor * image_width);
  view_height = (int)(zoom_factor * image_height);

  if (canvas_width < view_width)
    x = (int)floor(-posx*view_width);
  else
    x = (canvas_width - view_width) / 2;

  if (canvas_height < view_height)
  {
    /* posy is top-bottom, CD is bottom-top.
    invert posy reference (YMAX-DY - POSY) */
    float dy = IupGetFloat(ih, "DY");
    posy = 1.0f - dy - posy;
    y = (int)floor(-posy*view_height);
  }
  else
    y = (canvas_height - view_height) / 2;

  *_x = x;
  *_y = y;
  *_view_width = view_width;
  *_view_height = view_height;

  return zoom_factor;
}

static void view_zoom_offset(int view_x, int view_y, int image_width, int image_height, double zoom_factor, int *x, int *y)
{
  *x -= view_x;
  *y -= view_y;

  *x = (int)(*x / zoom_factor);
  *y = (int)(*y / zoom_factor);

  if (*x < 0) *x = 0;
  if (*y < 0) *y = 0;
  if (*x > image_width - 1) *x = image_width - 1;
  if (*y > image_height - 1) *y = image_height - 1;
}

static int tool_get_enter_cb(Ihandle* ih)
{
  IupSetAttribute(ih, "STATUS", "1");
  return IUP_CLOSE;
}

static int tool_get_esc_cb(Ihandle* ih)
{
  IupSetAttribute(ih, "STATUS", "0");
  return IUP_CLOSE;
}

static void tool_get_text(Ihandle* toolbox)
{
  Ihandle *text, *dlg;

  char* value = IupGetAttribute(toolbox, "TOOLTEXT");
  char* font = IupGetAttribute(toolbox, "TOOLFONT");

  text = IupText(NULL);
  IupSetAttribute(text, "EXPAND", "YES");
  IupSetStrAttribute(text, "VALUE", value);
  IupSetStrAttribute(text, "FONT", font);
  IupSetAttribute(text, "VISIBLECOLUMNS", "20");
  IupSetAttribute(text, "TIP", "Press Enter to select, Esc to cancel");

  dlg = IupDialog(IupVbox(IupLabel("Enter Text:"), text, NULL));

  IupSetAttribute(dlg, "MINBOX", "NO");
  IupSetAttribute(dlg, "MAXBOX", "NO");
  IupSetAttribute(dlg, "MENUBOX", "NO");
  IupSetCallback(dlg, "K_CR", (Icallback)tool_get_enter_cb);
  IupSetCallback(dlg, "K_ESC", (Icallback)tool_get_esc_cb);
  IupSetAttributeHandle(dlg, "PARENTDIALOG", IupGetDialog(toolbox));
  IupSetAttribute(dlg, "BGCOLOR", "255 255 255");
  IupSetAttribute(dlg, "RESIZE", "NO");

  IupPopup(dlg, IUP_MOUSEPOS, IUP_MOUSEPOS);

  if (IupGetInt(dlg, "STATUS"))
  {
    value = IupGetAttribute(text, "VALUE");
    IupSetStrAttribute(toolbox, "TOOLTEXT", value);
  }

  IupDestroy(dlg);
}

static void plot_line(unsigned char* data0, int width, int height, unsigned char index, int x0, int y0, int x1, int y1)
{
  int dx = abs(x1 - x0);
  int sx = x0 < x1 ? 1 : -1;
  int dy = -abs(y1 - y0);
  int sy = y0 < y1 ? 1 : -1;
  int e2, err = dx + dy;  /* error value e_xy */
  while (1)   /* loop */
  {
    if (x0 >= 0 && x0 <= width - 1 &&
        y0 >= 0 && y0 <= height - 1)
    {
      int offset = y0 * width + x0;
      data0[offset] = index;
    }

    if (x0 == x1 && y0 == y1) 
      break;

    e2 = 2 * err;
    if (e2 >= dy)
    {
      err += dy; /* e_xy+e_x > 0 */
      x0 += sx;
    }
    if (e2 <= dx) /* e_xy+e_y < 0 */
    {
      err += dx;
      y0 += sy;
    }
  }
}

static void tool_draw_pencil(Ihandle* toolbox, imImage* image, int start_x, int start_y, int end_x, int end_y)
{
  if (image->color_space == IM_MAP || image->color_space == IM_GRAY)
  {
    unsigned char** data = (unsigned char**)image->data;
    unsigned char index = (unsigned char)IupGetInt(toolbox, "TOOLCOLORINDEX");
    plot_line(data[0], image->width, image->height, index, start_x, start_y, end_x, end_y);
  }
  else
  {
    /* do not use line style here */
    cdCanvas* rgb_canvas = cdCreateCanvas(CD_IMIMAGE, image);
    int line_width = IupGetInt(toolbox, "TOOLWIDTH");
    double res = IupGetDouble(NULL, "SCREENDPI") / 25.4;
    unsigned char r, g, b, a;
    IupGetRGBA(toolbox, "TOOLCOLOR", &r, &g, &b, &a);
    cdCanvasSetfAttribute(rgb_canvas, "RESOLUTION", "%g", res);
    cdCanvasForeground(rgb_canvas, cdEncodeColorAlpha(r, g, b, a));
    cdCanvasLineWidth(rgb_canvas, line_width);
    cdCanvasLine(rgb_canvas, start_x, start_y, end_x, end_y);
    cdKillCanvas(rgb_canvas);
  }
}

static void tool_draw_overlay(Ihandle* toolbox, cdCanvas* cd_canvas, int start_x, int start_y, int end_x, int end_y)
{
  int tool_index = IupGetInt(toolbox, "TOOLINDEX");
  int line_width = IupGetInt(toolbox, "TOOLWIDTH");
  int line_style = IupGetInt(toolbox, "TOOLSTYLE") - 1;
  unsigned char r, g, b, a;
  IupGetRGBA(toolbox, "TOOLCOLOR", &r, &g, &b, &a);
  
  cdCanvasForeground(cd_canvas, cdEncodeColorAlpha(r, g, b, a));
  cdCanvasLineWidth(cd_canvas, line_width);
  if (line_width == 1)
    cdCanvasLineStyle(cd_canvas, line_style);

  if (tool_index == 3)  /* Line */
    cdCanvasLine(cd_canvas, start_x, start_y, end_x, end_y);
  else if (tool_index == 4)  /* Rect */
    cdCanvasRect(cd_canvas, start_x, end_x, start_y, end_y);
  else if (tool_index == 5)  /* Box */
    cdCanvasBox(cd_canvas, start_x, end_x, start_y, end_y);
  else if (tool_index == 6)  /* Ellipse */
    cdCanvasArc(cd_canvas, (end_x + start_x) / 2, (end_y + start_y) / 2, abs(end_x - start_x), abs(end_y - start_y), 0, 360);
  else if (tool_index == 7)  /* Oval */
    cdCanvasSector(cd_canvas, (end_x + start_x) / 2, (end_y + start_y) / 2, abs(end_x - start_x), abs(end_y - start_y), 0, 360);
  else if (tool_index == 8)  /* Text */
  {
    char* text = IupGetAttribute(toolbox, "TOOLTEXT");
    if (text)
    {
      cdCanvasTextAlignment(cd_canvas, CD_SOUTH_WEST);
      cdCanvasNativeFont(cd_canvas, IupGetAttribute(toolbox, "TOOLFONT"));
      cdCanvasText(cd_canvas, end_x, end_y, text);
    }
  }
}


/********************************** Callbacks *****************************************/


static int canvas_action_cb(Ihandle* canvas)
{
  unsigned int bg_r, bg_g, bg_b;
  imImage* image;
  cdCanvas* cd_canvas = (cdCanvas*)IupGetAttribute(canvas, "cdCanvas");
  Ihandle* config = (Ihandle*)IupGetAttribute(canvas, "CONFIG");
  const char* background = IupConfigGetVariableStrDef(config, "ImageEditor", "Background", "208 208 208");

  cdCanvasActivate(cd_canvas);

  /* draw the background */
  sscanf(background, "%u %u %u", &bg_r, &bg_g, &bg_b);
  cdCanvasBackground(cd_canvas, cdEncodeColor((unsigned char)bg_r, (unsigned char)bg_g, (unsigned char)bg_b));
  cdCanvasClear(cd_canvas);

  /* draw the image at the center of the canvas */
  image = (imImage*)IupGetAttribute(canvas, "IMAGE");
  if (image)
  {
    int x, y, view_width, view_height;
    view_zoom_rect(canvas, image->width, image->height, &x, &y, &view_width, &view_height);

    /* Some CD drivers have interpolation options for image zoom */
    /* we force NEAREST so we can see the pixel boundary in zoom in */
    /* an alternative would be to set BILINEAR when zoom out */
    cdCanvasSetAttribute(cd_canvas, "IMGINTERP", "NEAREST");  /* affects only drivers that have this attribute */
    cdCanvasPutImImage(cd_canvas, image, x, y, view_width, view_height);

    if (IupConfigGetVariableIntDef(config, "ImageEditor", "ZoomGrid", 1))
    {
      Ihandle* zoom_val = IupGetDialogChild(canvas, "ZOOMVAL");
      double zoom_index = IupGetDouble(zoom_val, "VALUE");
      if (zoom_index > 1)
      {
        int ix, iy;
        int bg_i = (bg_r+bg_g+bg_b)/3;
        double zoom_factor = pow(2, zoom_index);

        if (bg_i > 160)
          cdCanvasForeground(cd_canvas, CD_DARK_GRAY);
        else
          cdCanvasForeground(cd_canvas, CD_GRAY);

        for (ix = 0; ix <= image->width; ix++)
        {
          int gx = (int)(ix * zoom_factor);
          cdCanvasLine(cd_canvas, gx + x, y, gx + x, y + view_height);
        }
        for (iy = 0; iy <= image->height; iy++)
        {
          int gy = (int)(iy * zoom_factor);
          cdCanvasLine(cd_canvas, x, gy + y, x + view_width, gy + y);
        }
      }
    }

    if (IupGetAttribute(canvas, "OVERLAY"))
    {
      Ihandle* toolbox = IupGetDialogChild(canvas, "TOOLBOX");
      int start_x = IupGetInt(canvas, "START_X");
      int start_y = IupGetInt(canvas, "START_Y");
      int end_x = IupGetInt(canvas, "END_X");
      int end_y = IupGetInt(canvas, "END_Y");

      double scale_x = (double)view_width / (double)image->width;
      double scale_y = (double)view_height / (double)image->height;

      /* offset and scale drawing in screen to match the image */
      if (scale_x > 1 || scale_y > 1)
      {
        /* also draw at the center of the pixel when zoom in */
        cdCanvasTransformTranslate(cd_canvas, x + scale_x / 2, y + scale_y / 2);
      }
      else
        cdCanvasTransformTranslate(cd_canvas, x, y);
      cdCanvasTransformScale(cd_canvas, scale_x, scale_y);

      tool_draw_overlay(toolbox, cd_canvas, start_x, start_y, end_x, end_y);

      cdCanvasTransform(cd_canvas, NULL);
    }
  }

  cdCanvasFlush(cd_canvas);

  return IUP_DEFAULT;
}

static int canvas_map_cb(Ihandle* canvas)
{
  cdCanvas* cd_canvas;

  cd_canvas = cdCreateCanvas(CD_IUPDBUFFER, canvas);

  IupSetAttribute(canvas, "cdCanvas", (char*)cd_canvas);
  return IUP_DEFAULT;
}

static int canvas_unmap_cb(Ihandle* canvas)
{
  cdCanvas* cd_canvas = (cdCanvas*)IupGetAttribute(canvas, "cdCanvas");
  cdKillCanvas(cd_canvas);
  return IUP_DEFAULT;
}

static int zoomout_action_cb(Ihandle* ih)
{
  Ihandle* zoom_val = IupGetDialogChild(ih, "ZOOMVAL");
  double zoom_index = IupGetDouble(zoom_val, "VALUE");
  zoom_index--;
  if (zoom_index < -6)
    zoom_index = -6;
  IupSetDouble(zoom_val, "VALUE", round(zoom_index));  /* fixed increments when using buttons */

  zoom_update(ih, zoom_index);
  return IUP_DEFAULT;
}

static int zoomin_action_cb(Ihandle* ih)
{
  Ihandle* zoom_val = IupGetDialogChild(ih, "ZOOMVAL");
  double zoom_index = IupGetDouble(zoom_val, "VALUE");
  zoom_index++;
  if (zoom_index > 6)
    zoom_index = 6;
  IupSetDouble(zoom_val, "VALUE", round(zoom_index));  /* fixed increments when using buttons */

  zoom_update(ih, zoom_index);
  return IUP_DEFAULT;
}

static int actualsize_action_cb(Ihandle* ih)
{
  Ihandle* zoom_val = IupGetDialogChild(ih, "ZOOMVAL");
  IupSetDouble(zoom_val, "VALUE", 0);
  zoom_update(ih, 0);
  return IUP_DEFAULT;
}

static int canvas_resize_cb(Ihandle* canvas)
{
  imImage* image = (imImage*)IupGetAttribute(canvas, "IMAGE");
  if (image)
  {
    Ihandle* zoom_val = IupGetDialogChild(canvas, "ZOOMVAL");
    double zoom_index = IupGetDouble(zoom_val, "VALUE");
    double zoom_factor = pow(2, zoom_index);
    float old_center_x, old_center_y;

    int view_width = (int)(zoom_factor * image->width);
    int view_height = (int)(zoom_factor * image->height);

    scroll_calc_center(canvas, &old_center_x, &old_center_y);

    scroll_update(canvas, view_width, view_height);

    scroll_center(canvas, old_center_x, old_center_y);
  }
  return IUP_DEFAULT;
}

static int canvas_wheel_cb(Ihandle* canvas, float delta)
{
  if (IupGetInt(NULL, "CONTROLKEY"))
  {
    if (delta < 0)
      zoomout_action_cb(canvas);
    else
      zoomin_action_cb(canvas);
  }
  else
  {
    float posy = IupGetFloat(canvas, "POSY");
    posy -= delta * IupGetFloat(canvas, "DY") / 10.0f;
    IupSetFloat(canvas, "POSY", posy);
    IupUpdate(canvas);
  }
  return IUP_DEFAULT;
}

static int canvas_button_cb(Ihandle* canvas, int button, int pressed, int x, int y)
{
  imImage* image = (imImage*)IupGetAttribute(canvas, "IMAGE");
  if (image)
  {
    int cursor_x = x, cursor_y = y;
    int view_x, view_y, view_width, view_height;
    double zoom_factor = view_zoom_rect(canvas, image->width, image->height, &view_x, &view_y, &view_width, &view_height);

    /* y is top-down in IUP */
    int canvas_height = IupGetInt2(canvas, "DRAWSIZE");
    y = canvas_height - y - 1;

    /* inside image area */
    if (x > view_x && y > view_y && x < view_x + view_width && y < view_y + view_height)
    {
      view_zoom_offset(view_x, view_y, image->width, image->height, zoom_factor, &x, &y);

      if (button == IUP_BUTTON1)
      {
        Ihandle* toolbox = IupGetDialogChild(canvas, "TOOLBOX");
        int tool_index = IupGetInt(toolbox, "TOOLINDEX");

        if (pressed)
        {
          IupSetInt(canvas, "START_X", x);
          IupSetInt(canvas, "START_Y", y);
          IupSetInt(canvas, "START_CURSOR_X", cursor_x);
          IupSetInt(canvas, "START_CURSOR_Y", cursor_y);

          if (tool_index == 8)  /* Text */
          {
            IupSetInt(canvas, "END_X", x);
            IupSetInt(canvas, "END_Y", y);
            IupSetAttribute(canvas, "OVERLAY", "Yes");
            IupRedraw(canvas, 0);
          }
        }
        else
        {
          if (tool_index == 1)  /* Color Picker */
          {
            Ihandle* color = IupGetDialogChild(toolbox, "COLOR");
            unsigned char** data = (unsigned char**)image->data;
            unsigned char r, g, b, a = 255;
            int offset;

            offset = y * image->width + x;
            if (image->color_space == IM_RGB)
            {
              r = data[0][offset];
              g = data[1][offset];
              b = data[2][offset];
              if (image->has_alpha)
                a = data[3][offset];
            }
            else
            {
              unsigned char index = data[0][offset];
              long c = image->palette[index];
              r = cdRed(c);
              g = cdGreen(c);
              b = cdBlue(c);
              IupSetInt(toolbox, "TOOLCOLORINDEX", (int)index);
            }

            IupSetRGB(color, "BGCOLOR", r, g, b);
            IupSetRGBA(toolbox, "TOOLCOLOR", r, g, b, a);
          }
          else if (tool_index == 2)  /* Pencil */
          {
            int start_x = IupGetInt(canvas, "START_X");
            int start_y = IupGetInt(canvas, "START_Y");

            tool_draw_pencil(toolbox, image, start_x, start_y, x, y);

            IupSetAttribute(canvas, "DIRTY", "Yes");
            update_title(canvas);

            IupUpdate(canvas);

            IupSetInt(canvas, "START_X", x);
            IupSetInt(canvas, "START_Y", y);
          }
          else if (tool_index >= 3 && tool_index <= 8)  /* Shapes */
          {
            if (IupGetAttribute(canvas, "OVERLAY"))
            {
              int start_x = IupGetInt(canvas, "START_X");
              int start_y = IupGetInt(canvas, "START_Y");
              double res = IupGetDouble(NULL, "SCREENDPI") / 25.4;
  
              cdCanvas* rgb_canvas = cdCreateCanvas(CD_IMIMAGE, image);
              cdCanvasSetfAttribute(rgb_canvas, "RESOLUTION", "%g", res);

              tool_draw_overlay(toolbox, rgb_canvas, start_x, start_y, x, y);

              cdKillCanvas(rgb_canvas);

              IupSetAttribute(canvas, "OVERLAY", NULL);
              IupSetAttribute(canvas, "DIRTY", "Yes");
              update_title(canvas);

              IupUpdate(canvas);
            }
          }
          else if (tool_index == 9)  /* Fill Color */
          {
            double tol_percent = IupGetDouble(toolbox, "TOOLFILLTOL");
            unsigned char r, g, b, a;
            int index = IupGetInt(toolbox, "TOOLCOLORINDEX");
            IupGetRGBA(toolbox, "TOOLCOLOR", &r, &g, &b, &a);   

            image_flood_fill(image, x, y, cdEncodeColorAlpha(r, g, b, a), index, tol_percent);
            IupSetAttribute(canvas, "DIRTY", "Yes");
            update_title(canvas);

            IupUpdate(canvas);
          }
        }
      }
      else if (button == IUP_BUTTON3)
      {
        if (!pressed)
        {
          Ihandle* toolbox = IupGetDialogChild(canvas, "TOOLBOX");
          int tool_index = IupGetInt(toolbox, "TOOLINDEX");
          if (tool_index == 8)  /* Text */
            tool_get_text(toolbox);
        }
      }
    }
  }

  return IUP_DEFAULT;
}

static int canvas_motion_cb(Ihandle* canvas, int x, int y, char *status)
{
  imImage* image = (imImage*)IupGetAttribute(canvas, "IMAGE");
  if (image)
  {
    int cursor_x = x, cursor_y = y;
    int view_x, view_y, view_width, view_height;
    double zoom_factor = view_zoom_rect(canvas, image->width, image->height, &view_x, &view_y, &view_width, &view_height);

    /* y is top-down in IUP */
    int canvas_height = IupGetInt2(canvas, "DRAWSIZE");
    y = canvas_height - y - 1;

    /* inside image area */
    if (x > view_x && y > view_y && x < view_x + view_width && y < view_y + view_height)
    {
      Ihandle* status_lbl = IupGetDialogChild(canvas, "STATUSLABEL");
      unsigned char** data = (unsigned char**)image->data;
      unsigned char r, g, b;
      int offset;

      view_zoom_offset(view_x, view_y, image->width, image->height, zoom_factor, &x, &y);

      offset = y * image->width + x; 
      if (image->color_space == IM_RGB)
      {
        r = data[0][offset];
        g = data[1][offset];
        b = data[2][offset];
        if (image->has_alpha)
        {
          unsigned char a = data[3][offset];
          IupSetStrf(status_lbl, "TITLE", "(%4d, %4d) = %3d %3d %3d %3d", x, y, (int)r, (int)g, (int)b, (int)a);
        }
        else
          IupSetStrf(status_lbl, "TITLE", "(%4d, %4d) = %3d %3d %3d", x, y, (int)r, (int)g, (int)b);
      }
      else
      {
        const unsigned char* transp_index = imImageGetAttribute(image, "TransparencyIndex", NULL, NULL);
        unsigned char index = data[0][offset];
        long color = image->palette[index];
        r = cdRed(color);
        g = cdGreen(color);
        b = cdBlue(color);

        if (transp_index && index == *transp_index)
          IupSetStrf(status_lbl, "TITLE", "(%4d, %4d) = %3d [BGCOLOR]", x, y, (int)index);
        else
          IupSetStrf(status_lbl, "TITLE", "(%4d, %4d) = %3d [%3d %3d %3d]", x, y, (int)index, (int)r, (int)g, (int)b);
      }

      if (iup_isbutton1(status)) /* button1 is pressed */
      {
        Ihandle* toolbox = IupGetDialogChild(canvas, "TOOLBOX");
        int tool_index = IupGetInt(toolbox, "TOOLINDEX");

        if (tool_index == 0)  /* Pointer */
        {
          int start_cursor_x = IupGetInt(canvas, "START_CURSOR_X");
          int start_cursor_y = IupGetInt(canvas, "START_CURSOR_Y");

          int canvas_width = IupGetInt(canvas, "DRAWSIZE");

          scroll_move(canvas, canvas_width, canvas_height, cursor_x - start_cursor_x, cursor_y - start_cursor_y, view_width, view_height);

          IupSetInt(canvas, "START_CURSOR_X", cursor_x);
          IupSetInt(canvas, "START_CURSOR_Y", cursor_y);
        }
        else if (tool_index == 2)  /* Pencil */
        {
          int start_x = IupGetInt(canvas, "START_X");
          int start_y = IupGetInt(canvas, "START_Y");

          tool_draw_pencil(toolbox, image, start_x, start_y, x, y);

          IupSetAttribute(canvas, "DIRTY", "Yes");
          update_title(canvas);

          IupRedraw(canvas, 0);

          IupSetInt(canvas, "START_X", x);
          IupSetInt(canvas, "START_Y", y);
        }
        else if (tool_index >= 3 && tool_index <= 8)  /* Shapes */
        {
          IupSetInt(canvas, "END_X", x);
          IupSetInt(canvas, "END_Y", y);
          IupSetAttribute(canvas, "OVERLAY", "Yes");
          IupRedraw(canvas, 0);
        }
      }
    }
  }

  return IUP_DEFAULT;
}

static int zoom_valuechanged_cb(Ihandle* val)
{
  double zoom_index = IupGetDouble(val, "VALUE");
  zoom_update(val, zoom_index);
  return IUP_DEFAULT;
}

static int dropfiles_cb(Ihandle* ih, const char* filename)
{
  import_file(ih, filename);
  return IUP_DEFAULT;
}

static int file_menu_open_cb(Ihandle* ih)
{
  Ihandle* item_revert = IupGetDialogChild(ih, "ITEM_REVERT");
  Ihandle* item_save = IupGetDialogChild(ih, "ITEM_SAVE");
  Ihandle* canvas = IupGetDialogChild(ih, "CANVAS");
  int dirty = IupGetInt(canvas, "DIRTY");
  if (dirty)
  {
    IupSetAttribute(item_save, "ACTIVE", "YES");
    IupSetAttribute(item_revert, "ACTIVE", "YES");
  }
  else
  {
    IupSetAttribute(item_save, "ACTIVE", "NO");
    IupSetAttribute(item_revert, "ACTIVE", "NO");
  }

  return IUP_DEFAULT;
}

static int image_menu_open_cb(Ihandle* ih)
{
  Ihandle* item_palette = IupGetDialogChild(ih, "ITEM_PALETTE");
  Ihandle* item_map = IupGetDialogChild(ih, "ITEM_MAP");
  Ihandle* item_rgb = IupGetBrother(item_map);
  Ihandle* item_rgba = IupGetBrother(item_rgb);
  Ihandle* canvas = IupGetDialogChild(ih, "CANVAS");
  imImage* image = (imImage*)IupGetAttribute(canvas, "IMAGE");

  if (image->color_space == IM_MAP || image->color_space == IM_GRAY)
  {
    IupSetAttribute(item_palette, "ACTIVE", "YES");
    IupSetAttribute(item_map, "VALUE", "ON");
    IupSetAttribute(item_rgb, "VALUE", "OFF");
    IupSetAttribute(item_rgba, "VALUE", "OFF");
  }
  else
  {
    IupSetAttribute(item_palette, "ACTIVE", "NO");
    IupSetAttribute(item_map, "VALUE", "OFF");
    if (image->has_alpha)
    {
      IupSetAttribute(item_rgb, "VALUE", "OFF");
      IupSetAttribute(item_rgba, "VALUE", "ON");
    }
    else
    {
      IupSetAttribute(item_rgb, "VALUE", "ON");
      IupSetAttribute(item_rgba, "VALUE", "OFF");
    }
  }

  return IUP_DEFAULT;
}

static int edit_menu_open_cb(Ihandle* ih)
{
  Ihandle *clipboard = IupClipboard(); 

  Ihandle *item_paste = IupGetDialogChild(ih, "ITEM_PASTE");

  if (!IupGetInt(clipboard, "IMAGEAVAILABLE"))
    IupSetAttribute(item_paste, "ACTIVE", "NO");
  else
    IupSetAttribute(item_paste, "ACTIVE", "YES");

  IupDestroy(clipboard);
  return IUP_DEFAULT;
}

void vLedImageEditorNewImage(Ihandle* dlg, const char* filename)
{
  Ihandle* canvas = IupGetDialogChild(dlg, "CANVAS");
  Ihandle* config = (Ihandle*)IupGetAttribute(canvas, "CONFIG");
  int width = IupConfigGetVariableIntDef(config, "NewImage", "Width", 32);
  int height = IupConfigGetVariableIntDef(config, "NewImage", "Height", 32);
  int type = IupConfigGetVariableIntDef(config, "NewImage", "Type", 1);
  char name[512];
  static int new_img_count = 1;

  sprintf(name, "new_image%d", new_img_count);

  if (IupGetParam("New Image", NULL, NULL,
                  "Name: %s\n"
                  "Width: %i[1,]\n"
                  "Height: %i[1,]\n"
                  "Type: %l|MAP|RGB|RGBA|\n",
                  name, &width, &height, &type, NULL))
  {
    Ihandle* iup_image;
    int color_space = type == 0 ? IM_MAP : IM_RGB;
    imImage* image;
    Icallback imagechanged_cb;
    Ihandle* old_elem = IupGetHandle(name);

    IupConfigSetVariableInt(config, "NewImage", "Width", width);
    IupConfigSetVariableInt(config, "NewImage", "Height", height);
    IupConfigSetVariableInt(config, "NewImage", "Type", type);

    if (old_elem)
    {
      if (IupMessageAlarm(dlg, "Handle Name", "Name is already associated with another handle. Replace it?", "YESNO") == 0)
        return;
    }

    image = imImageCreate(width, height, color_space, IM_BYTE);
    if (!image)
    {
      show_file_error(IM_ERR_MEM);
      return;
    }

    if (type == 2)
      imImageAddAlpha(image);

    image_fill_white(image);

    iup_image = IupImageFromImImage(image);
    if (!iup_image)
    {
      imImageDestroy(image);
      show_file_error(IM_ERR_MEM);
      return;
    }

    new_img_count++;

    IupSetAttribute(canvas, "IUP_IMAGE", (char*)iup_image);
    IupSetStrAttribute(canvas, "IUP_IMAGE_NAME", name);
    IupSetStrAttribute(canvas, "_IUPLED_FILENAME", filename);

    IupSetHandle(name, iup_image);
    IupSetStrAttribute(iup_image, "_IUPLED_FILENAME", filename);

    set_new_image(canvas, image, 0);

    imagechanged_cb = IupGetCallback(IupGetDialog(canvas), "IMAGECHANGED_CB");
    if (imagechanged_cb)
      imagechanged_cb(IupGetDialog(canvas));
  }
}

static int item_new_action_cb(Ihandle* item_new)
{
  if (save_check(item_new))
  {
    Ihandle* canvas = IupGetDialogChild(item_new, "CANVAS");
    char* filename = IupGetAttribute(canvas, "_IUPLED_FILENAME");
    vLedImageEditorNewImage(IupGetDialog(item_new), filename);
  }

  return IUP_DEFAULT;
}

static int item_import_action_cb(Ihandle* item)
{
  return select_file(IupGetDialog(item), 1);
}

static int item_export_action_cb(Ihandle* item)
{
  return select_file(IupGetDialog(item), 0);
}

static int compare_names(const void *a, const void *b)
{
  return strcmp(*(char**)a, *(char**)b);
}

static int item_open_action_cb(Ihandle* item)
{
  if (save_check(item))
  {
    Ihandle* canvas = IupGetDialogChild(item, "CANVAS");
    char* filename = IupGetAttribute(canvas, "_IUPLED_FILENAME");
    int num_images, ret;
    int i, num_names = IupGetAllNames(NULL, -1);
    char* *names = malloc(sizeof(char*)*num_names);
    char* *image_names = malloc(sizeof(char*)*num_names);

    IupGetAllNames(names, num_names);

    num_images = 0;
    for (i = 0; i < num_names; i++)
    {
      Ihandle *elem = IupGetHandle(names[i]);
      char* type = IupGetClassType(elem);

      if (type && strcmp(type, "image") == 0)  /* only images */
      {
        char* elem_filename = IupGetAttribute(elem, "_IUPLED_FILENAME");
        if (elem_filename && strcmp(elem_filename, filename) == 0)  /* only of the current LED file */
        {
          image_names[num_images] = names[i];
          num_images++;
        }
      }
    }

    if (num_images == 0)
    {
      IupMessageError(IupGetDialog(item), "No images.");
      free(names);
      free(image_names);
      return IUP_DEFAULT;
    }

    qsort(image_names, num_images, sizeof(Ihandle*), compare_names);

    ret = IupListDialog(1, "Open Image", num_images, image_names, 1, 30, 10, NULL);
    if (ret != -1)
    {
      char* name = image_names[ret];
      Ihandle* iup_image = IupGetHandle(name);
      imImage* image = IupImageToImImage(iup_image);
      if (!image)
        show_file_error(IM_ERR_MEM);
      else
      {
        IupSetAttribute(canvas, "IUP_IMAGE", (char*)iup_image);
        IupSetStrAttribute(canvas, "IUP_IMAGE_NAME", name);

        set_new_image(canvas, image, 0);
      }
    }

    free(names);
    free(image_names);
  }

  return IUP_DEFAULT;
}

static int item_save_action_cb(Ihandle* item_save)
{
  Ihandle* canvas = IupGetDialogChild(item_save, "CANVAS");
  /* test again because in can be called using the hot key */
  int dirty = IupGetInt(canvas, "DIRTY");
  if (dirty)
    save_iup_image(canvas);
  return IUP_DEFAULT;
}

static int item_revert_action_cb(Ihandle* item)
{
  Ihandle* canvas = IupGetDialogChild(item, "CANVAS");
  Ihandle* iup_image = (Ihandle*)IupGetAttribute(canvas, "IUP_IMAGE");
  imImage* image = IupImageToImImage(iup_image);
  if (!image)
  {
    show_file_error(IM_ERR_MEM);
    return IUP_DEFAULT;
  }

  set_new_image(canvas, image, 0);
  return IUP_DEFAULT;
}

static int item_close_action_cb(Ihandle* item_close)
{
  Ihandle* dlg = IupGetDialog(item_close);
  Ihandle* config = (Ihandle*)IupGetAttribute(dlg, "CONFIG");
  Ihandle* canvas = IupGetDialogChild(dlg, "CANVAS");
  imImage* image = (imImage*)IupGetAttribute(canvas, "IMAGE");

  if (!save_check(item_close))
    return IUP_IGNORE;  /* to abort the CLOSE_CB callback */

  if (image)
    imImageDestroy(image);

  IupSetAttribute(canvas, "IMAGE", NULL);
  IupSetAttribute(canvas, "IUP_IMAGE", NULL);
  IupSetAttribute(canvas, "IUP_IMAGE_NAME", NULL);
  IupSetAttribute(canvas, "_IUPLED_FILENAME", NULL);

  IupConfigDialogClosed(config, dlg, "ImageEditorDialog");
  return IUP_CLOSE;
}

static int item_copy_action_cb(Ihandle* item_copy)
{
  Ihandle* canvas = IupGetDialogChild(item_copy, "CANVAS");
  imImage* image = (imImage*)IupGetAttribute(canvas, "IMAGE");
  Ihandle *clipboard = IupClipboard();
  IupSetAttribute(clipboard, "NATIVEIMAGE", (char*)IupGetImageNativeHandle(image));
  IupDestroy(clipboard);
  return IUP_DEFAULT;
}

static int item_paste_action_cb(Ihandle* item_paste)
{
  Ihandle* canvas = IupGetDialogChild(item_paste, "CANVAS");

  Ihandle *clipboard = IupClipboard();
  imImage* image = IupGetNativeHandleImage(IupGetAttribute(clipboard, "NATIVEIMAGE"));
  IupDestroy(clipboard);

  if (!image)
  {
    show_error("Invalid Clipboard Data", 1);
    return IUP_DEFAULT;
  }

  set_new_image(canvas, image, 1);  /* set dirty */
  return IUP_DEFAULT;
}

static int item_background_action_cb(Ihandle* item_background)
{
  Ihandle* canvas = IupGetDialogChild(item_background, "CANVAS");
  Ihandle* config = (Ihandle*)IupGetAttribute(canvas, "CONFIG");
  Ihandle* colordlg = IupColorDlg();
  const char* background = IupConfigGetVariableStrDef(config, "ImageEditor", "Background", "208 208 208");
  IupSetStrAttribute(colordlg, "VALUE", background);
  IupSetAttributeHandle(colordlg, "PARENTDIALOG", IupGetDialog(item_background));

  IupPopup(colordlg, IUP_CENTERPARENT, IUP_CENTERPARENT);

  if (IupGetInt(colordlg, "STATUS") == 1)
  {
    imImage* image = (imImage*)IupGetAttribute(canvas, "IMAGE");

    background = IupGetAttribute(colordlg, "VALUE");
    IupConfigSetVariableStr(config, "ImageEditor", "Background", background);

    if (image->color_space == IM_MAP || image->color_space == IM_GRAY)
    {
      const unsigned char* transp_index = imImageGetAttribute(image, "TransparencyIndex", NULL, NULL);
      if (transp_index)
      {
        int index = (int)(*transp_index);
        unsigned int ri, gi, bi;
        sscanf(background, "%u %u %u", &ri, &gi, &bi);

        image->palette[index] = cdEncodeColor((unsigned char)ri, (unsigned char)gi, (unsigned char)bi);
      }
    }

    IupUpdate(canvas);
  }

  IupDestroy(colordlg);
  return IUP_DEFAULT;
}

static int item_zoomgrid_action_cb(Ihandle* ih)
{
  Ihandle* item_zoomgrid = IupGetDialogChild(ih, "ITEM_ZOOMGRID");
  Ihandle* canvas = IupGetDialogChild(ih, "CANVAS");
  Ihandle* config = (Ihandle*)IupGetAttribute(ih, "CONFIG");

  if (ih == item_zoomgrid)
  {
    Ihandle* btn_zoomgrid = IupGetDialogChild(ih, "BTN_ZOOMGRID");
    if (IupGetInt(btn_zoomgrid, "VALUE"))
      IupSetAttribute(btn_zoomgrid, "VALUE", "OFF");
    else
      IupSetAttribute(btn_zoomgrid, "VALUE", "ON");
  }
  else
  {
    if (IupGetInt(item_zoomgrid, "VALUE"))
      IupSetAttribute(item_zoomgrid, "VALUE", "OFF");
    else
      IupSetAttribute(item_zoomgrid, "VALUE", "ON");
  }

  IupConfigSetVariableStr(config, "ImageEditor", "ZoomGrid", IupGetAttribute(item_zoomgrid, "VALUE"));

  IupUpdate(canvas);
  return IUP_DEFAULT;
}

static int item_toolbar_action_cb(Ihandle* item_toolbar)
{
  Ihandle* toolbar = IupGetDialogChild(item_toolbar, "TOOLBAR");
  Ihandle* config = (Ihandle*)IupGetAttribute(item_toolbar, "CONFIG");

  toggle_bar_visibility(item_toolbar, toolbar);

  IupConfigSetVariableStr(config, "ImageEditor", "Toolbar", IupGetAttribute(item_toolbar, "VALUE"));
  return IUP_DEFAULT;
}

static int item_toolbox_action_cb(Ihandle* item_toolbox)
{
  Ihandle* toolbox = IupGetDialogChild(item_toolbox, "TOOLBOX");
  Ihandle* config = (Ihandle*)IupGetAttribute(item_toolbox, "CONFIG");

  toggle_bar_visibility(item_toolbox, toolbox);

  IupConfigSetVariableStr(config, "ImageEditor", "Toolbox", IupGetAttribute(item_toolbox, "VALUE"));
  return IUP_DEFAULT;
}

static int item_statusbar_action_cb(Ihandle* item_statusbar)
{
  Ihandle* statusbar = IupGetDialogChild(item_statusbar, "STATUSBAR");
  Ihandle* config = (Ihandle*)IupGetAttribute(item_statusbar, "CONFIG");

  toggle_bar_visibility(item_statusbar, statusbar);

  IupConfigSetVariableStr(config, "ImageEditor", "Statusbar", IupGetAttribute(item_statusbar, "VALUE"));
  return IUP_DEFAULT;
}

static int tool_action_cb(Ihandle* ih, int state)
{
  if (state == 1)
  {
    Ihandle* toolbox = IupGetDialogChild(ih, "TOOLBOX");
    Ihandle* canvas = IupGetDialogChild(ih, "CANVAS");
    imImage* image = (imImage*)IupGetAttribute(canvas, "IMAGE");
    int tool_index = IupGetInt(ih, "TOOLINDEX"); /* here is from the ih */
    if (image->color_space == IM_MAP || image->color_space == IM_GRAY)
    {
      if (tool_index >= 3 && tool_index <= 8)
        return IUP_DEFAULT;
    }

    IupSetInt(toolbox, "TOOLINDEX", tool_index);

    if (tool_index == 0)
      IupSetAttribute(canvas, "CURSOR", "ARROW");
    else
      IupSetAttribute(canvas, "CURSOR", "CROSS");

    if (tool_index == 8)
      tool_get_text(toolbox);
  }
  return IUP_DEFAULT;
}

static int tool_text_button_cb(Ihandle* ih, int button, int pressed, int x, int y, char* status)
{
  (void)x;
  (void)y;
  (void)status;
  if (button == IUP_BUTTON1 && pressed)
  {
    if (IupGetInt(ih, "VALUE")) /* already checked */
    {
      Ihandle* toolbox = IupGetDialogChild(ih, "TOOLBOX");
      tool_get_text(toolbox);
    }
  }

  return IUP_DEFAULT;
}

static int colorbar_select_cb(Ihandle* ih, int index, int type)
{
  if (type == IUP_PRIMARY)
  {
    Ihandle *lbl = (Ihandle*)IupGetAttribute(ih, "STATUS_LABEL");
    int transp_index = IupGetInt(ih, "TRANSP_INDEX");
    unsigned char r, g, b;
    IupGetRGBId(ih, "CELL", index, &r, &g, &b);

    if (index == transp_index)
      IupSetStrf(lbl, "TITLE", "%3d [BGCOLOR]", (int)index);
    else
      IupSetStrf(lbl, "TITLE", "%3d [%3d %3d %3d]", (int)index, (int)r, (int)g, (int)b);
  }
  return IUP_DEFAULT;
}

static int toolcolor_action_cb(Ihandle* ih)
{
  Ihandle* toolbox = IupGetDialogChild(ih, "TOOLBOX");
  Ihandle* canvas = IupGetDialogChild(ih, "CANVAS");
  imImage* image = (imImage*)IupGetAttribute(canvas, "IMAGE");

  if (image->color_space == IM_MAP || image->color_space == IM_GRAY)
  {
    Ihandle *colorbar, *lbl, *dlg;
    int index, i, transp_index = -1;
    long* palette = image->palette;
    int pal_count = image->palette_count;

    const unsigned char* img_transp_index = imImageGetAttribute(image, "TransparencyIndex", NULL, NULL);
    if (img_transp_index)
      transp_index = (int)(*img_transp_index);

    lbl = IupLabel("");
    IupSetAttribute(lbl, "EXPAND", "HORIZONTAL");

    colorbar = IupColorbar();
    IupSetAttribute(colorbar, "RASTERSIZE", "840x200");
    IupSetAttribute(colorbar, "FLAT", "YES");
    IupSetAttribute(colorbar, "FOCUSSELECT", "YES");
    IupSetAttribute(colorbar, "ORIENTATION", "HORIZONTAL");
    IupSetAttribute(colorbar, "NUM_CELLS", "256");
    IupSetAttribute(colorbar, "NUM_PARTS", "8");
    IupSetAttribute(colorbar, "PREVIEW_SIZE", "64");
    IupSetCallback(colorbar, "SELECT_CB", (Icallback)colorbar_select_cb);
    IupSetInt(colorbar, "TRANSP_INDEX", transp_index);
    IupSetAttribute(colorbar, "TIP", "Press Enter to select, Esc to cancel");
    IupSetAttribute(colorbar, "STATUS_LABEL", (char*)lbl);

    for (i = 0; i < pal_count; i++)
      IupSetRGBId(colorbar, "CELL", i, cdRed(palette[i]), cdGreen(palette[i]), cdBlue(palette[i]));

    index = IupGetInt(toolbox, "TOOLCOLORINDEX");
    IupSetInt(colorbar, "PRIMARY_CELL", index);

    dlg = IupDialog(IupVbox(IupLabel("Select Color:"), colorbar, lbl, NULL));

    IupSetAttribute(dlg, "MINBOX", "NO");
    IupSetAttribute(dlg, "MAXBOX", "NO");
    IupSetAttribute(dlg, "MENUBOX", "NO");
    IupSetAttribute(dlg, "MARGIN", "3x3");
    IupSetAttribute(dlg, "BGCOLOR", "255 255 255");
    IupSetAttribute(dlg, "RESIZE", "NO");
    IupSetCallback(dlg, "K_CR", (Icallback)tool_get_enter_cb);
    IupSetCallback(dlg, "K_ESC", (Icallback)tool_get_esc_cb);
    IupSetAttributeHandle(dlg, "PARENTDIALOG", toolbox);

    IupPopup(dlg, IUP_MOUSEPOS, IUP_MOUSEPOS);

    if (IupGetInt(dlg, "STATUS"))
    {
      index = IupGetInt(colorbar, "PRIMARY_CELL");
      IupSetInt(toolbox, "TOOLCOLORINDEX", index);
      IupSetRGB(toolbox, "TOOLCOLOR", cdRed(palette[index]), cdGreen(palette[index]), cdBlue(palette[index]));
      IupSetRGB(ih, "BGCOLOR", cdRed(palette[index]), cdGreen(palette[index]), cdBlue(palette[index]));
    }

    IupDestroy(dlg);
  }
  else
  {
    Ihandle* colordlg = IupColorDlg();
    const char* color = IupGetAttribute(toolbox, "TOOLCOLOR");

    IupSetStrAttribute(colordlg, "VALUE", color);
    IupSetAttributeHandle(colordlg, "PARENTDIALOG", toolbox);

    if (image->has_alpha)
      IupSetStrAttribute(colordlg, "SHOWALPHA", "Yes");

    IupPopup(colordlg, IUP_MOUSEPOS, IUP_MOUSEPOS);

    if (IupGetInt(colordlg, "STATUS") == 1)
    {
      color = IupGetAttribute(colordlg, "VALUE");

      IupSetStrAttribute(toolbox, "TOOLCOLOR", color);
      IupSetStrAttribute(ih, "BGCOLOR", color);
    }

    IupDestroy(colordlg);
  }

  return IUP_DEFAULT;
}

static int toolwidth_valuechanged_cb(Ihandle* ih)
{
  Ihandle* toolbox = IupGetDialogChild(ih, "TOOLBOX");
  char* value = IupGetAttribute(ih, "VALUE");
  IupSetStrAttribute(toolbox, "TOOLWIDTH", value);
  return IUP_DEFAULT;
}

static int toolstyle_valuechanged_cb(Ihandle* ih)
{
  Ihandle* toolbox = IupGetDialogChild(ih, "TOOLBOX");
  char* value = IupGetAttribute(ih, "VALUE");
  IupSetStrAttribute(toolbox, "TOOLSTYLE", value);
  return IUP_DEFAULT;
}

static int toolfont_action_cb(Ihandle* ih)
{
  Ihandle* font_dlg = IupFontDlg();
  char* font = IupGetAttribute(ih, "TOOLFONT");
  IupSetAttributeHandle(font_dlg, "PARENTDIALOG", IupGetDialog(ih));
  IupSetStrAttribute(font_dlg, "VALUE", font);

  IupPopup(font_dlg, IUP_MOUSEPOS, IUP_MOUSEPOS);

  if (IupGetInt(font_dlg, "STATUS") == 1)
  {
    Ihandle* toolbox = IupGetDialogChild(ih, "TOOLBOX");
    font = IupGetAttribute(font_dlg, "VALUE");
    IupSetStrAttribute(toolbox, "TOOLFONT", font);
  }
  IupDestroy(font_dlg);
  return IUP_DEFAULT;
}

static int toolfilltol_valuechanged_cb(Ihandle* ih)
{
  Ihandle* toolbox = IupGetDialogChild(ih, "TOOLBOX");
  Ihandle* filltol_label = IupGetDialogChild(ih, "FILLTOLLABEL");
  double value = IupGetDouble(ih, "VALUE");
  IupSetStrf(filltol_label, "TITLE", "Tol.: %.0f%%", value);
  IupSetDouble(toolbox, "TOOLFILLTOL", value);
  return IUP_DEFAULT;
}

static int item_map_action_cb(Ihandle* item)
{
  Ihandle* canvas = IupGetDialogChild(item, "CANVAS");
  imImage* image = (imImage*)IupGetAttribute(canvas, "IMAGE");
  imImage* new_image = imImageCreateBased(image, -1, -1, IM_MAP, -1);
  if (!new_image)
  {
    show_file_error(IM_ERR_MEM);
    return IUP_DEFAULT;
  }

  imProcessConvertColorSpace(image, new_image);  /* RGB to MAP */

  update_image(canvas, new_image, 0);

  return IUP_DEFAULT;
}

static int item_rgb_action_cb(Ihandle* item)
{
  Ihandle* canvas = IupGetDialogChild(item, "CANVAS");
  imImage* image = (imImage*)IupGetAttribute(canvas, "IMAGE");

  if (image->color_space == IM_RGB)
  {
    /* just remove alpha */
    imImageRemoveAlpha(image);

    IupSetAttribute(canvas, "DIRTY", "Yes");
    update_title(canvas);

    IupUpdate(canvas);
  }
  else
  {
    imImage* new_image = imImageCreateBased(image, -1, -1, IM_RGB, -1);
    if (!new_image)
    {
      show_file_error(IM_ERR_MEM);
      return IUP_DEFAULT;
    }

    imProcessConvertColorSpace(image, new_image);  /* MAP to RGB */

    update_image(canvas, new_image, 0);
  }

  return IUP_DEFAULT;
}

static int item_rgba_action_cb(Ihandle* item)
{
  Ihandle* canvas = IupGetDialogChild(item, "CANVAS");
  imImage* image = (imImage*)IupGetAttribute(canvas, "IMAGE");

  if (image->color_space == IM_RGB)
  {
    /* just add alpha */
    imImageAddAlpha(image);
    imImageSetAlpha(image, 255); /* opaque */

    IupSetAttribute(canvas, "DIRTY", "Yes");
    update_title(canvas);

    IupUpdate(canvas);
  }
  else
  {
    imImage* new_image = imImageCreateBased(image, -1, -1, IM_RGB, -1);
    if (!new_image)
    {
      show_file_error(IM_ERR_MEM);
      return IUP_DEFAULT;
    }

    imImageAddAlpha(new_image);
    imImageSetAlpha(image, 255); /* opaque */

    imProcessConvertColorSpace(image, new_image);  /* MAP to RGB with alpha */

    update_image(canvas, new_image, 0);
  }

  return IUP_DEFAULT;
}

static char* colorbar_cell_cb(Ihandle* colorbar, int cell)
{
  Ihandle* colordlg = IupColorDlg();
  IupSetStrAttribute(colordlg, "VALUE", IupGetAttributeId(colorbar, "CELL", cell));
  IupSetAttributeHandle(colordlg, "PARENTDIALOG", IupGetDialog(colorbar));

  IupPopup(colordlg, IUP_CENTERPARENT, IUP_CENTERPARENT);

  if (IupGetInt(colordlg, "STATUS") == 1)
    IupSetStrAttributeId(colorbar, "CELL", cell, IupGetAttribute(colordlg, "VALUE"));

  IupDestroy(colordlg);

  return NULL;  /* we already changed */
}

static int palette_ok_cb(Ihandle* bt_ok)
{
  IupSetAttribute(IupGetDialog(bt_ok), "STATUS", "1");
  return IUP_CLOSE;
}

static int palette_cancel_cb(Ihandle* bt_cancel)
{
  IupSetAttribute(IupGetDialog(bt_cancel), "STATUS", "0");
  return IUP_CLOSE;
}

static int palette_compact_cb(Ihandle* bt)
{
  imImage* image = (imImage*)IupGetAttribute(bt, "IM_IMAGE");
  Ihandle* colorbar = IupGetChild(IupGetParent(IupGetParent(bt)), 0);
  int i, j, count = image->count, transp_index = -1;
  unsigned char* data = (unsigned char*)image->data[0];
  long* palette = image->palette;
  unsigned char map[256];
  long bgcolor = 0;

  const unsigned char* img_transp_index = imImageGetAttribute(image, "TransparencyIndex", NULL, NULL);
  if (img_transp_index)
  {
    transp_index = (int)(*img_transp_index);
    bgcolor = palette[transp_index];
  }

  memset(map, 0, 256);

  for (i = 0; i < count; i++)
  {
    if (map[data[i]] == 0)
      map[data[i]] = 1;
  }

  j = 0;
  for (i = 0; i < 256; i++)
  {
    if (map[i])
    {
      map[i] = (unsigned char)j;
      j++;
    }
  }

  for (i = 0; i < count; i++)
  {
    data[i] = map[data[i]];
  }

  for (i = 0; i < j; i++)
    palette[i] = palette[map[i]];

  for (i = j; i < 256; i++)
    palette[i] = 0;

  if (transp_index != -1)
  {
    transp_index = map[transp_index];
    palette[transp_index] = bgcolor;
  }

  for (i = 0; i < 256; i++)
    IupSetRGBId(colorbar, "CELL", i, cdRed(palette[i]), cdGreen(palette[i]), cdBlue(palette[i]));

  IupSetAttribute(IupGetDialog(bt), "COMPACTED", "1");

  if (transp_index != -1)
  {
    unsigned char new_img_transp_index = (unsigned char)transp_index;
    imImageSetAttribute(image, "TransparencyIndex", IM_BYTE, 1, &new_img_transp_index);

    IupSetInt(colorbar, "TRANSP_INDEX", transp_index);
  }

  return IUP_DEFAULT;
}

static int item_palette_action_cb(Ihandle* item)
{
  Ihandle *colorbar, *lbl, *dlg, *bt_ok, *bt_cancel, *bt_compact;
  int i, transp_index = -1;
  Ihandle* canvas = IupGetDialogChild(item, "CANVAS");
  imImage* image = (imImage*)IupGetAttribute(canvas, "IMAGE");
  long* palette = image->palette;
  int pal_count = image->palette_count;

  const unsigned char* img_transp_index = imImageGetAttribute(image, "TransparencyIndex", NULL, NULL);
  if (img_transp_index)
    transp_index = (int)(*img_transp_index);

  lbl = IupLabel("");
  IupSetAttribute(lbl, "EXPAND", "HORIZONTAL");

  colorbar = IupColorbar();
  IupSetAttribute(colorbar, "RASTERSIZE", "900x235");
  IupSetAttribute(colorbar, "FLAT", "YES");
  IupSetAttribute(colorbar, "FOCUSSELECT", "YES");
  IupSetAttribute(colorbar, "ORIENTATION", "HORIZONTAL");
  IupSetAttribute(colorbar, "NUM_CELLS", "256");
  IupSetAttribute(colorbar, "NUM_PARTS", "8");
  IupSetAttribute(colorbar, "SHOW_PREVIEW", "NO");
  IupSetCallback(colorbar, "SELECT_CB", (Icallback)colorbar_select_cb);
  IupSetCallback(colorbar, "CELL_CB", (Icallback)colorbar_cell_cb);
  IupSetInt(colorbar, "TRANSP_INDEX", transp_index);
  IupSetAttribute(colorbar, "STATUS_LABEL", (char*)lbl);

  bt_ok = IupButton("OK", NULL);
  IupSetAttribute(bt_ok, "PADDING", "DEFAULTBUTTONPADDING");
  IupSetCallback(bt_ok, "ACTION", (Icallback)palette_ok_cb);

  bt_cancel = IupButton("Cancel", NULL);
  IupSetCallback(bt_cancel, "ACTION", (Icallback)palette_cancel_cb);
  IupSetAttribute(bt_cancel, "PADDING", "DEFAULTBUTTONPADDING");

  bt_compact = IupButton("Compact", NULL);
  IupSetCallback(bt_compact, "ACTION", (Icallback)palette_compact_cb);
  IupSetAttribute(bt_compact, "PADDING", "DEFAULTBUTTONPADDING");

  for (i = 0; i < pal_count; i++)
    IupSetRGBId(colorbar, "CELL", i, cdRed(palette[i]), cdGreen(palette[i]), cdBlue(palette[i]));

  dlg = IupDialog(IupVbox(colorbar, IupSetAttributes(IupHbox(lbl, bt_compact, bt_ok, bt_cancel, NULL), "NORMALIZESIZE=HORIZONTAL"), NULL));

  IupSetAttribute(dlg, "TITLE", "Palette");
  IupSetAttribute(dlg, "MINBOX", "NO");
  IupSetAttribute(dlg, "MAXBOX", "NO");
  IupSetAttribute(dlg, "MARGIN", "5x5");
  IupSetAttribute(dlg, "GAP", "5");
  IupSetAttribute(dlg, "BGCOLOR", "255 255 255");
  IupSetAttribute(dlg, "RESIZE", "NO");
  IupSetCallback(dlg, "K_CR", (Icallback)tool_get_enter_cb);
  IupSetCallback(dlg, "K_ESC", (Icallback)tool_get_esc_cb);
  IupSetAttributeHandle(dlg, "PARENTDIALOG", IupGetDialog(canvas));
  IupSetAttribute(dlg, "IM_IMAGE", (char*)image);

  IupPopup(dlg, IUP_CENTERPARENT, IUP_CENTERPARENT);

  if (IupGetInt(dlg, "STATUS"))
  {
    unsigned char r, g, b;

    for (i = 0; i < pal_count; i++)
    {
      IupGetRGBId(colorbar, "CELL", i, &r, &g, &b);
      palette[i] = cdEncodeColor(r, g, b);
    }

    IupSetAttribute(canvas, "DIRTY", "Yes");
    update_title(canvas);

    IupUpdate(canvas);
  }
  else if (IupGetInt(dlg, "COMPACTED"))
  {
    IupSetAttribute(canvas, "DIRTY", "Yes");
    update_title(canvas);

    IupUpdate(canvas);
  }

  IupDestroy(dlg);
  return IUP_DEFAULT;
}

static int item_resize_action_cb(Ihandle* ih)
{
  Ihandle* config = (Ihandle*)IupGetAttribute(ih, "CONFIG");
  Ihandle* canvas = IupGetDialogChild(ih, "CANVAS");
  imImage* image = (imImage*)IupGetAttribute(canvas, "IMAGE");
  imImage* new_image;
  int height = image->height, 
      width = image->width;
  int quality = IupConfigGetVariableIntDef(config, "ImageEditor", "ResizeQuality", 1);  /* medium default */

  if (!IupGetParam("Resize", NULL, NULL, 
                   "Width: %i[1,]\n"
                   "Height: %i[1,]\n"
                   "Quality: %l|low|medium|high|\n",
                   &width, &height, &quality, NULL))
    return IUP_DEFAULT;

  IupConfigSetVariableInt(config, "ImageEditor", "ResizeQuality", quality);

  new_image = imImageCreateBased(image, width, height, -1, -1);
  if (!new_image)
  {
    show_file_error(IM_ERR_MEM);
    return IUP_DEFAULT;
  }

  if (quality == 2)
    quality = 3; /* interpolation order can be 0, 1, and 3 */

  imProcessResize(image, new_image, quality);

  update_image(canvas, new_image, 1);   /* update size */

  return IUP_DEFAULT;
}

static int item_mirror_action_cb(Ihandle* ih)
{
  Ihandle* canvas = IupGetDialogChild(ih, "CANVAS");
  imImage* image = (imImage*)IupGetAttribute(canvas, "IMAGE");
  imImage* new_image = imImageClone(image);
  if (!new_image)
  {
    show_file_error(IM_ERR_MEM);
    return IUP_DEFAULT;
  }

  imProcessMirror(image, new_image);

  update_image(canvas, new_image, 0);

  return IUP_DEFAULT;
}

static int item_flip_action_cb(Ihandle* ih)
{
  Ihandle* canvas = IupGetDialogChild(ih, "CANVAS");
  imImage* image = (imImage*)IupGetAttribute(canvas, "IMAGE");
  imImage* new_image = imImageClone(image);
  if (!new_image)
  {
    show_file_error(IM_ERR_MEM);
    return IUP_DEFAULT;
  }

  imProcessFlip(image, new_image);

  update_image(canvas, new_image, 0);

  return IUP_DEFAULT;
}

static int item_rotate180_action_cb(Ihandle* ih)
{
  Ihandle* canvas = IupGetDialogChild(ih, "CANVAS");
  imImage* image = (imImage*)IupGetAttribute(canvas, "IMAGE");
  imImage* new_image = imImageClone(image);
  if (!new_image)
  {
    show_file_error(IM_ERR_MEM);
    return IUP_DEFAULT;
  }

  imProcessRotate180(image, new_image);

  update_image(canvas, new_image, 0);

  return IUP_DEFAULT;
}

static int item_rotate90cw_action_cb(Ihandle* ih)
{
  Ihandle* canvas = IupGetDialogChild(ih, "CANVAS");
  imImage* image = (imImage*)IupGetAttribute(canvas, "IMAGE");
  imImage* new_image = imImageCreateBased(image, image->height, image->width, -1, -1);
  if (!new_image)
  {
    show_file_error(IM_ERR_MEM);
    return IUP_DEFAULT;
  }

  imProcessRotate90(image, new_image, 1);

  update_image(canvas, new_image, 1);   /* update size */

  return IUP_DEFAULT;
}

static int item_rotate90ccw_action_cb(Ihandle* ih)
{
  Ihandle* canvas = IupGetDialogChild(ih, "CANVAS");
  imImage* image = (imImage*)IupGetAttribute(canvas, "IMAGE");
  imImage* new_image = imImageCreateBased(image, image->height, image->width, -1, -1);
  if (!new_image)
  {
    show_file_error(IM_ERR_MEM);
    return IUP_DEFAULT;
  }

  imProcessRotate90(image, new_image, -1);

  update_image(canvas, new_image, 1);   /* update size */

  return IUP_DEFAULT;
}

static int item_negative_action_cb(Ihandle* ih)
{
  Ihandle* canvas = IupGetDialogChild(ih, "CANVAS");
  imImage* image = (imImage*)IupGetAttribute(canvas, "IMAGE");
  imImage* new_image = imImageClone(image);
  if (!new_image)
  {
    show_file_error(IM_ERR_MEM);
    return IUP_DEFAULT;
  }

  imProcessNegative(image, new_image);

  update_image(canvas, new_image, 0);

  return IUP_DEFAULT;
}

static int brightcont_param_cb(Ihandle* dialog, int param_index, void* user_data)
{
  Ihandle* canvas = (Ihandle*)user_data;

  if (param_index == 0 || param_index == 1)
  {
    double param[2] = { 0, 0 };
    imImage* image = (imImage*)IupGetAttribute(canvas, "ORIGINAL_IMAGE");
    imImage* new_image = (imImage*)IupGetAttribute(canvas, "NEW_IMAGE");
    Ihandle* brightness_shift_param = (Ihandle*)IupGetAttribute(dialog, "PARAM0");
    Ihandle* contrast_factor_param = (Ihandle*)IupGetAttribute(dialog, "PARAM1");
    param[0] = IupGetDouble(brightness_shift_param, "VALUE");
    param[1] = IupGetDouble(contrast_factor_param, "VALUE");

    imProcessToneGamut(image, new_image, IM_GAMUT_BRIGHTCONT, param);

    IupSetAttribute(canvas, "IMAGE", (char*)new_image);
    IupRedraw(canvas, 0);
  }
  else if (param_index != IUP_GETPARAM_INIT && param_index != IUP_GETPARAM_MAP)
  {
    /* restore original configuration */
    imImage* image = (imImage*)IupGetAttribute(canvas, "ORIGINAL_IMAGE");
    IupSetAttribute(canvas, "IMAGE", (char*)image);
    IupSetAttribute(canvas, "ORIGINAL_IMAGE", NULL);
    IupSetAttribute(canvas, "NEW_IMAGE", NULL);

    if (param_index == IUP_GETPARAM_BUTTON2)  /* cancel */
      IupUpdate(canvas);
  }

  return 1;
}

static int item_brightcont_action_cb(Ihandle* ih)
{
  double param[2] = { 0, 0 };
  Ihandle* canvas = IupGetDialogChild(ih, "CANVAS");
  imImage* image = (imImage*)IupGetAttribute(canvas, "IMAGE");
  imImage* new_image = imImageClone(image);
  if (!new_image)
  {
    show_file_error(IM_ERR_MEM);
    return IUP_DEFAULT;
  }

  IupSetAttribute(canvas, "ORIGINAL_IMAGE", (char*)image);
  IupSetAttribute(canvas, "NEW_IMAGE", (char*)new_image);

  if (!IupGetParam("Brightness and Contrast", brightcont_param_cb, canvas,
                   "Brightness Shift: %R[-100,100]\n"
                   "Contrast Factor: %R[-100,100]\n",
                   &param[0], &param[1], NULL))
  {
    imImageDestroy(new_image);
	  return IUP_DEFAULT;
  }

  imProcessToneGamut(image, new_image, IM_GAMUT_BRIGHTCONT, param);

  update_image(canvas, new_image, 0);

  return IUP_DEFAULT;
}


/********************************** Main *****************************************/


static Ihandle* create_menu(Ihandle *config)
{
  Ihandle *menu;
  Ihandle *file_menu, *item_close, *item_new, *item_open, *item_save, *item_revert;
  Ihandle *edit_menu, *item_copy, *item_paste, *item_import, *item_export;
  Ihandle *view_menu, *item_toolbar, *item_statusbar;
  Ihandle *item_zoomin, *item_zoomout, *item_actualsize;
  Ihandle *item_background, *item_toolbox, *item_zoomgrid;
  Ihandle *image_menu, *item_map, *item_rgb, *item_rgba, *item_palette;

  item_new = IupItem("&New\tCtrl+N", NULL);
  IupSetAttribute(item_new, "IMAGE", "IUP_FileNew");
  IupSetCallback(item_new, "ACTION", (Icallback)item_new_action_cb);

  item_open = IupItem("&Open...\tCtrl+O", NULL);
  IupSetAttribute(item_open, "IMAGE", "IUP_FileOpen");
  IupSetCallback(item_open, "ACTION", (Icallback)item_open_action_cb);

  item_save = IupItem("&Save\tCtrl+S", NULL);
  IupSetAttribute(item_save, "NAME", "ITEM_SAVE");
  IupSetAttribute(item_save, "IMAGE", "IUP_FileSave");
  IupSetCallback(item_save, "ACTION", (Icallback)item_save_action_cb);

  item_revert = IupItem("&Revert", NULL);
  IupSetAttribute(item_revert, "NAME", "ITEM_REVERT");
  IupSetCallback(item_revert, "ACTION", (Icallback)item_revert_action_cb);

  item_import = IupItem("&Import...", NULL);
  IupSetAttribute(item_import, "IMAGE", "IUP_FileOpen");
  IupSetCallback(item_import, "ACTION", (Icallback)item_import_action_cb);

  item_export = IupItem("&Export...", NULL);
  IupSetAttribute(item_export, "IMAGE", "IUP_FileSave");
  IupSetCallback(item_export, "ACTION", (Icallback)item_export_action_cb);

  item_close = IupItem("&Close", NULL);
  IupSetCallback(item_close, "ACTION", (Icallback)item_close_action_cb);

  item_copy = IupItem("&Copy\tCtrl+C", NULL);
  IupSetAttribute(item_copy, "NAME", "ITEM_COPY");
  IupSetAttribute(item_copy, "IMAGE", "IUP_EditCopy");
  IupSetCallback(item_copy, "ACTION", (Icallback)item_copy_action_cb);

  item_paste = IupItem("&Paste\tCtrl+V", NULL);
  IupSetAttribute(item_paste, "NAME", "ITEM_PASTE");
  IupSetAttribute(item_paste, "IMAGE", "IUP_EditPaste");
  IupSetCallback(item_paste, "ACTION", (Icallback)item_paste_action_cb);

  item_zoomin = IupItem("Zoom &In\tCtrl++", NULL);
  IupSetAttribute(item_zoomin, "IMAGE", "IUP_ZoomIn");
  IupSetCallback(item_zoomin, "ACTION", (Icallback)zoomin_action_cb);

  item_zoomout = IupItem("Zoom &Out\tCtrl+-", NULL);
  IupSetAttribute(item_zoomout, "IMAGE", "IUP_ZoomOut");
  IupSetCallback(item_zoomout, "ACTION", (Icallback)zoomout_action_cb);

  item_actualsize = IupItem("&Actual Size\tCtrl+0", NULL);
  IupSetAttribute(item_actualsize, "IMAGE", "IUP_ZoomActualSize");
  IupSetCallback(item_actualsize, "ACTION", (Icallback)actualsize_action_cb);

  item_zoomgrid = IupItem("&Zoom Grid", NULL);
  IupSetCallback(item_zoomgrid, "ACTION", (Icallback)item_zoomgrid_action_cb);
  IupSetAttribute(item_zoomgrid, "NAME", "ITEM_ZOOMGRID");
  IupSetAttribute(item_zoomgrid, "AUTOTOGGLE", "Yes");
  IupSetAttribute(item_zoomgrid, "VALUE", "ON");  /* default is ON */

  item_background = IupItem("&Background...", NULL);
  IupSetCallback(item_background, "ACTION", (Icallback)item_background_action_cb);

  item_toolbar = IupItem("&Toobar", NULL);
  IupSetCallback(item_toolbar, "ACTION", (Icallback)item_toolbar_action_cb);
  IupSetAttribute(item_toolbar, "VALUE", "ON");   /* default is ON */

  item_toolbox = IupItem("&Toobox", NULL);
  IupSetCallback(item_toolbox, "ACTION", (Icallback)item_toolbox_action_cb);
  IupSetAttribute(item_toolbox, "VALUE", "ON");   /* default is ON */

  item_statusbar = IupItem("&Statusbar", NULL);
  IupSetCallback(item_statusbar, "ACTION", (Icallback)item_statusbar_action_cb);
  IupSetAttribute(item_statusbar, "VALUE", "ON");  /* default is ON */

  item_map = IupItem("&Map", NULL);
  IupSetCallback(item_map, "ACTION", (Icallback)item_map_action_cb);
  IupSetAttribute(item_map, "NAME", "ITEM_MAP");

  item_rgb = IupItem("&RGB", NULL);
  IupSetCallback(item_rgb, "ACTION", (Icallback)item_rgb_action_cb);

  item_rgba = IupItem("RGB&A", NULL);
  IupSetCallback(item_rgba, "ACTION", (Icallback)item_rgba_action_cb);

  item_palette = IupItem("&Palette...", NULL);
  IupSetCallback(item_palette, "ACTION", (Icallback)item_palette_action_cb);
  IupSetAttribute(item_palette, "NAME", "ITEM_PALETTE");
  

  file_menu = IupMenu(
    item_new,
    item_open,
    item_save,
    item_revert,
    IupSeparator(),
    item_import,
    item_export,
    IupSeparator(),
    item_close,
    NULL);
  edit_menu = IupMenu(
    item_copy,
    item_paste,
    NULL);
  view_menu = IupMenu(
    item_zoomin,
    item_zoomout,
    item_actualsize,
    item_zoomgrid,
    IupSeparator(),
    item_background,
    IupSeparator(),
    item_toolbar,
    item_toolbox,
    item_statusbar,
    NULL);
  image_menu = IupMenu(
    IupSubmenu("&Type", IupMenu(
      item_map,
      item_rgb,
      item_rgba,
      NULL)),
    item_palette,
    IupSeparator(),
    IupSetCallbacks(IupItem("&Resize...", NULL), "ACTION", item_resize_action_cb, NULL),
    IupSetCallbacks(IupItem("&Mirror", NULL), "ACTION", item_mirror_action_cb, NULL),
    IupSetCallbacks(IupItem("&Flip", NULL), "ACTION", item_flip_action_cb, NULL),
    IupSetCallbacks(IupItem("Rotate 180", NULL), "ACTION", item_rotate180_action_cb, NULL),
    IupSetCallbacks(IupItem("Rotate +90 (clock-wise)", NULL), "ACTION", item_rotate90cw_action_cb, NULL),
    IupSetCallbacks(IupItem("Rotate -90 (counter-clock)", NULL), "ACTION", item_rotate90ccw_action_cb, NULL),
    IupSeparator(),
    IupSetCallbacks(IupItem("&Negative", NULL), "ACTION", item_negative_action_cb, NULL),
    IupSetCallbacks(IupItem("&Brightness and Contrast...", NULL), "ACTION", item_brightcont_action_cb, NULL),
    NULL);
  
  IupSetCallback(file_menu, "OPEN_CB", (Icallback)file_menu_open_cb);
  IupSetCallback(edit_menu, "OPEN_CB", (Icallback)edit_menu_open_cb);
  IupSetCallback(image_menu, "OPEN_CB", (Icallback)image_menu_open_cb);

  menu = IupMenu(
    IupSubmenu("&File", file_menu),
    IupSubmenu("&Edit", edit_menu),
    IupSubmenu("&View", view_menu),
    IupSubmenu("&Image", image_menu),
    NULL);

  /* Initialize variables from the configuration file */

  if (!IupConfigGetVariableIntDef(config, "ImageEditor", "ZoomGrid", 1))
    IupSetAttribute(item_zoomgrid, "VALUE", "OFF");

  if (!IupConfigGetVariableIntDef(config, "ImageEditor", "Toolbar", 1))
    IupSetAttribute(item_toolbar, "VALUE", "OFF");

  if (!IupConfigGetVariableIntDef(config, "ImageEditor", "Toolbox", 1))
    IupSetAttribute(item_toolbox, "VALUE", "OFF");

  if (!IupConfigGetVariableIntDef(config, "ImageEditor", "Statusbar", 1))
    IupSetAttribute(item_statusbar, "VALUE", "OFF");

  return menu;
}

static Ihandle* create_toolbar(Ihandle *config)
{
  Ihandle *toolbar;
  Ihandle *btn_copy, *btn_paste, *btn_new, *btn_open, *btn_save, *btn_zoomgrid;

  btn_new = IupButton(NULL, NULL);
  IupSetAttribute(btn_new, "IMAGE", "IUP_FileNew");
  IupSetAttribute(btn_new, "FLAT", "Yes");
  IupSetCallback(btn_new, "ACTION", (Icallback)item_new_action_cb);
  IupSetAttribute(btn_new, "TIP", "New (Ctrl+N)");
  IupSetAttribute(btn_new, "CANFOCUS", "No");

  btn_open = IupButton(NULL, NULL);
  IupSetAttribute(btn_open, "IMAGE", "IUP_FileOpen");
  IupSetAttribute(btn_open, "FLAT", "Yes");
  IupSetCallback(btn_open, "ACTION", (Icallback)item_open_action_cb);
  IupSetAttribute(btn_open, "TIP", "Open (Ctrl+O)");
  IupSetAttribute(btn_open, "CANFOCUS", "No");

  btn_save = IupButton(NULL, NULL);
  IupSetAttribute(btn_save, "IMAGE", "IUP_FileSave");
  IupSetAttribute(btn_save, "FLAT", "Yes");
  IupSetCallback(btn_save, "ACTION", (Icallback)item_save_action_cb);
  IupSetAttribute(btn_save, "TIP", "Save (Ctrl+S)");
  IupSetAttribute(btn_save, "CANFOCUS", "No");

  btn_copy = IupButton(NULL, NULL);
  IupSetAttribute(btn_copy, "IMAGE", "IUP_EditCopy");
  IupSetAttribute(btn_copy, "FLAT", "Yes");
  IupSetCallback(btn_copy, "ACTION", (Icallback)item_copy_action_cb);
  IupSetAttribute(btn_copy, "TIP", "Copy (Ctrl+C)");
  IupSetAttribute(btn_copy, "CANFOCUS", "No");

  btn_paste = IupButton(NULL, NULL);
  IupSetAttribute(btn_paste, "IMAGE", "IUP_EditPaste");
  IupSetAttribute(btn_paste, "FLAT", "Yes");
  IupSetCallback(btn_paste, "ACTION", (Icallback)item_paste_action_cb);
  IupSetAttribute(btn_paste, "TIP", "Paste (Ctrl+V)");
  IupSetAttribute(btn_paste, "CANFOCUS", "No");

  btn_zoomgrid = IupToggle(NULL, NULL);
  IupSetAttribute(btn_zoomgrid, "IMAGE", "IupVLedPaintZoomGrid");
  IupSetAttribute(btn_zoomgrid, "FLAT", "Yes");
  IupSetCallback(btn_zoomgrid, "ACTION", (Icallback)item_zoomgrid_action_cb);
  IupSetAttribute(btn_zoomgrid, "TIP", "Zoom Grid");
  IupSetAttribute(btn_zoomgrid, "CANFOCUS", "No");
  IupSetAttribute(btn_zoomgrid, "VALUE", "ON");  /* default is ON */
  IupSetAttribute(btn_zoomgrid, "NAME", "BTN_ZOOMGRID");

  toolbar = IupHbox(
    btn_new,
    btn_open,
    btn_save,
    IupSetAttributes(IupLabel(NULL), "SEPARATOR=VERTICAL"),
    btn_copy,
    btn_paste,
    IupSetAttributes(IupLabel(NULL), "SEPARATOR=VERTICAL"),
    btn_zoomgrid,
    NULL);
  IupSetAttribute(toolbar, "MARGIN", "5x5");
  IupSetAttribute(toolbar, "GAP", "2");
  IupSetAttribute(toolbar, "NAME", "TOOLBAR");

  /* Initialize variables from the configuration file */

  if (!IupConfigGetVariableIntDef(config, "ImageEditor", "Toolbar", 1))
  {
    IupSetAttribute(toolbar, "FLOATING", "YES");
    IupSetAttribute(toolbar, "VISIBLE", "NO");
  }

  if (!IupConfigGetVariableIntDef(config, "ImageEditor", "ZoomGrid", 1))
    IupSetAttribute(btn_zoomgrid, "VALUE", "OFF");

  return toolbar;
}

static void init_images(void)
{
  if (!IupGetHandle("IupVLedPaintPointer"))
  {
    IupSetHandle("IupVLedPaintPointer", load_image_Pointer());
    IupSetHandle("IupVLedPaintColorPicker", load_image_PaintColorPicker());
    IupSetHandle("IupVLedPaintPencil", load_image_PaintPencil());
    IupSetHandle("IupVLedPaintLine", load_image_PaintLine());
    IupSetHandle("IupVLedPaintEllipse", load_image_PaintEllipse());
    IupSetHandle("IupVLedPaintRect", load_image_PaintRect());
    IupSetHandle("IupVLedPaintOval", load_image_PaintOval());
    IupSetHandle("IupVLedPaintBox", load_image_PaintBox());
    IupSetHandle("IupVLedPaintFill", load_image_PaintFill());
    IupSetHandle("IupVLedPaintText", load_image_PaintText());
    IupSetHandle("IupVLedPaintZoomGrid", load_image_PaintZoomGrid());
  }
}

static Ihandle* create_toolbox(Ihandle* canvas)
{
  Ihandle *toolbox, *gbox, *vbox;

  gbox = IupGridBox(
    IupSetCallbacks(IupSetAttributes(IupFlatToggle(NULL), "TOOLINDEX=0, IMAGE=IupVLedPaintPointer, VALUE=ON, CHECKSIZE=0, TIP=\"Pointer\", NAME=TOOL_POINTER"), "FLAT_ACTION", (Icallback)tool_action_cb, NULL),
    IupSetCallbacks(IupSetAttributes(IupFlatToggle(NULL), "TOOLINDEX=1, IMAGE=IupVLedPaintColorPicker, CHECKSIZE=0, TIP=\"Color Picker\""), "FLAT_ACTION", (Icallback)tool_action_cb, NULL),
    IupSetCallbacks(IupSetAttributes(IupFlatToggle(NULL), "TOOLINDEX=2, IMAGE=IupVLedPaintPencil, CHECKSIZE=0, TIP=\"Pencil\""), "FLAT_ACTION", (Icallback)tool_action_cb, NULL),
    IupSetCallbacks(IupSetAttributes(IupFlatToggle(NULL), "TOOLINDEX=3, IMAGE=IupVLedPaintLine, CHECKSIZE=0, TIP=\"Line\""), "FLAT_ACTION", (Icallback)tool_action_cb, NULL),
    IupSetCallbacks(IupSetAttributes(IupFlatToggle(NULL), "TOOLINDEX=4, IMAGE=IupVLedPaintRect, CHECKSIZE=0, TIP=\"Hollow Rectangle\""), "FLAT_ACTION", (Icallback)tool_action_cb, NULL),
    IupSetCallbacks(IupSetAttributes(IupFlatToggle(NULL), "TOOLINDEX=5, IMAGE=IupVLedPaintBox, CHECKSIZE=0, TIP=\"Box (Filled Rectangle)\""), "FLAT_ACTION", (Icallback)tool_action_cb, NULL),
    IupSetCallbacks(IupSetAttributes(IupFlatToggle(NULL), "TOOLINDEX=6, IMAGE=IupVLedPaintEllipse, CHECKSIZE=0, TIP=\"Hollow Ellipse\""), "FLAT_ACTION", (Icallback)tool_action_cb, NULL),
    IupSetCallbacks(IupSetAttributes(IupFlatToggle(NULL), "TOOLINDEX=7, IMAGE=IupVLedPaintOval, CHECKSIZE=0, TIP=\"Oval (Filled Ellipse)\""), "FLAT_ACTION", (Icallback)tool_action_cb, NULL),
    IupSetCallbacks(IupSetAttributes(IupFlatToggle(NULL), "TOOLINDEX=8, IMAGE=IupVLedPaintText, CHECKSIZE=0, TIP=\"Text\""), "FLAT_ACTION", (Icallback)tool_action_cb, "FLAT_BUTTON_CB", tool_text_button_cb, NULL),
    IupSetCallbacks(IupSetAttributes(IupFlatToggle(NULL), "TOOLINDEX=9, IMAGE=IupVLedPaintFill, CHECKSIZE=0, TIP=\"Fill Color\""), "FLAT_ACTION", (Icallback)tool_action_cb, NULL),
    NULL);
  IupSetAttribute(gbox, "GAPCOL", "2");
  IupSetAttribute(gbox, "GAPLIN", "2");
  IupSetAttribute(gbox, "MARGIN", "5x10");
  IupSetAttribute(gbox, "NUMDIV", "2");

  vbox = IupVbox(
    IupRadio(gbox),
    IupSetAttributes(IupFlatSeparator(), "ORIENTATION=HORIZONTAL"),
    IupSetAttributes(IupVbox(
      IupSetAttributes(IupLabel("Color:"), "EXPAND=HORIZONTALFREE"),
      IupSetCallbacks(IupSetAttributes(IupButton(NULL, NULL), "NAME=COLOR, BGCOLOR=\"0 0 0\", SIZE=20x10"), "ACTION", toolcolor_action_cb, NULL),
      IupSetAttributes(IupLabel("Width:"), "EXPAND=HORIZONTALFREE"),
      IupSetCallbacks(IupSetAttributes(IupText(NULL), "SPIN=Yes, SPINMIN=1, SIZE=30x10"), "VALUECHANGED_CB", toolwidth_valuechanged_cb, NULL),
      IupSetAttributes(IupLabel("Style:"), "EXPAND=HORIZONTALFREE"),
      IupSetCallbacks(IupSetAttributes(IupList(NULL), "DROPDOWN=Yes, VALUE=1, 1=\"____\", 2=\"----\", 3=\"....\", 4=\"-.-.\", 5=\"-..-..\""), "VALUECHANGED_CB", toolstyle_valuechanged_cb, NULL),
      IupSetAttributes(IupLabel("Tol.: 50%"), "EXPAND=HORIZONTALFREE, NAME=FILLTOLLABEL"),
      IupSetCallbacks(IupSetAttributes(IupVal(NULL), "NAME=FILLTOL, EXPAND=HORIZONTALFREE, SIZE=x12, VALUE=50, MAX=100"), "VALUECHANGED_CB", toolfilltol_valuechanged_cb, NULL),
      IupSetAttributes(IupLabel("Font:"), "EXPAND=HORIZONTALFREE"),
      IupSetCallbacks(IupSetAttributes(IupButton("F", NULL), "NAME=FONT, SIZE=16x8, FONT=\"Times, Bold Italic 11\""), "ACTION", toolfont_action_cb, NULL),
      NULL), "GAP=2, ALIGNMENT=ACENTER"),
    NULL);
  IupSetAttribute(vbox, "NMARGIN", "2x2");
  IupSetAttribute(vbox, "ALIGNMENT", "ACENTER");

  toolbox = IupFrame(vbox);
  IupSetAttribute(toolbox, "TITLE", "Tools");
  IupSetAttribute(toolbox, "FONTSIZE", "8");
  IupSetAttribute(toolbox, "NAME", "TOOLBOX");

  IupSetAttribute(toolbox, "TOOLCOLOR", "0 0 0 255");
  IupSetAttribute(toolbox, "TOOLWIDTH", "1");
  IupSetAttribute(toolbox, "TOOLSTYLE", "1");
  IupSetAttribute(toolbox, "TOOLFILLTOL", "50");
  IupSetStrAttribute(toolbox, "TOOLFONT", IupGetAttribute(canvas, "FONT"));

  return toolbox;
}

static Ihandle* create_statusbar(Ihandle *config)
{
  Ihandle *statusbar;

  statusbar = IupHbox(
    IupSetAttributes(IupLabel("(0, 0) = 0   0   0"), "EXPAND=HORIZONTAL, PADDING=10x5, NAME=STATUSLABEL"),
    IupSetAttributes(IupLabel(NULL), "SEPARATOR=VERTICAL"),
    IupSetAttributes(IupLabel("0 x 0"), "SIZE=70x, PADDING=10x5, NAME=SIZELABEL, ALIGNMENT=ACENTER"),
    IupSetAttributes(IupLabel(NULL), "SEPARATOR=VERTICAL"),
    IupSetAttributes(IupLabel("100%"), "SIZE=30x, PADDING=10x5, NAME=ZOOMLABEL, ALIGNMENT=ARIGHT"),
    IupSetCallbacks(IupSetAttributes(IupButton(NULL, NULL), "IMAGE=IUP_ZoomOut, FLAT=Yes, TIP=\"Zoom Out (Ctrl+-)\""), "ACTION", zoomout_action_cb, NULL),
    IupSetCallbacks(IupSetAttributes(IupVal(NULL), "VALUE=0, MIN=-6, MAX=6, SIZE=70x12, NAME=ZOOMVAL"), "VALUECHANGED_CB", zoom_valuechanged_cb, NULL),
    IupSetCallbacks(IupSetAttributes(IupButton(NULL, NULL), "IMAGE=IUP_ZoomIn, FLAT=Yes, TIP=\"Zoom In (Ctrl++)\""), "ACTION", zoomin_action_cb, NULL),
    IupSetCallbacks(IupSetAttributes(IupButton(NULL, NULL), "IMAGE=IUP_ZoomActualSize, FLAT=Yes, TIP=\"Actual Size (Ctrl+0)\""), "ACTION", actualsize_action_cb, NULL),
    NULL);
  IupSetAttribute(statusbar, "NAME", "STATUSBAR");
  IupSetAttribute(statusbar, "ALIGNMENT", "ACENTER");

  /* Initialize variables from the configuration file */

  if (!IupConfigGetVariableIntDef(config, "ImageEditor", "Statusbar", 1))
  {
    IupSetAttribute(statusbar, "FLOATING", "YES");
    IupSetAttribute(statusbar, "VISIBLE", "NO");
  }

  return statusbar;
}

Ihandle* vLedImageEditorCreate(Ihandle* parent, Ihandle *config)
{
  Ihandle *dlg, *vbox, *canvas, *toolbox;

  init_images();

  canvas = IupCanvas(NULL);
  IupSetAttribute(canvas, "NAME", "CANVAS");
  IupSetAttribute(canvas, "SCROLLBAR", "Yes");
  IupSetAttribute(canvas, "BORDER", "NO");
  IupSetCallback(canvas, "ACTION", (Icallback)canvas_action_cb);
  IupSetCallback(canvas, "DROPFILES_CB", (Icallback)dropfiles_cb);
  IupSetCallback(canvas, "MAP_CB", (Icallback)canvas_map_cb);
  IupSetCallback(canvas, "UNMAP_CB", (Icallback)canvas_unmap_cb);
  IupSetCallback(canvas, "WHEEL_CB", (Icallback)canvas_wheel_cb);
  IupSetCallback(canvas, "RESIZE_CB", (Icallback)canvas_resize_cb);
  IupSetCallback(canvas, "MOTION_CB", (Icallback)canvas_motion_cb);
  IupSetCallback(canvas, "BUTTON_CB", (Icallback)canvas_button_cb);

  IupSetAttribute(canvas, "DIRTY", "NO");  /* custom attribute */

  toolbox = create_toolbox(canvas);

  vbox = IupVbox(
    create_toolbar(config),
    IupHbox(
      toolbox,
      canvas,
      NULL),
    create_statusbar(config),
    NULL);

  dlg = IupDialog(vbox);
  IupSetAttribute(dlg, "TITLE", "Image Editor");
  IupSetAttributeHandle(dlg, "MENU", create_menu(config));
  IupSetAttributeHandle(dlg, "PARENTDIALOG", parent);
  IupSetCallback(dlg, "CLOSE_CB", (Icallback)item_close_action_cb);
  IupSetCallback(dlg, "DROPFILES_CB", (Icallback)dropfiles_cb);

  IupSetCallback(dlg, "K_cN", (Icallback)item_new_action_cb);
  IupSetCallback(dlg, "K_cO", (Icallback)item_open_action_cb);
  IupSetCallback(dlg, "K_cS", (Icallback)item_save_action_cb);
  IupSetCallback(dlg, "K_cV", (Icallback)item_paste_action_cb);
  IupSetCallback(dlg, "K_cC", (Icallback)item_copy_action_cb);
  IupSetCallback(dlg, "K_cMinus", (Icallback)zoomout_action_cb);
  IupSetCallback(dlg, "K_cPlus", (Icallback)zoomin_action_cb);
  IupSetCallback(dlg, "K_cEqual", (Icallback)zoomin_action_cb);
  IupSetCallback(dlg, "K_c0", (Icallback)actualsize_action_cb);

  IupSetAttribute(dlg, "CONFIG", (char*)config);

  return dlg;
}

void vLedImageEditorSetImage(Ihandle* dlg, Ihandle* iup_image, const char* name)
{
  Ihandle* canvas = IupGetDialogChild(dlg, "CANVAS");
  char* filename = IupGetAttribute(iup_image, "_IUPLED_FILENAME");
  imImage* image = IupImageToImImage(iup_image);
  if (!image)
  {
    imImage* old_image = (imImage*)IupGetAttribute(canvas, "IMAGE");
    show_file_error(IM_ERR_MEM);
    if (!old_image)
    {
      Ihandle* config = (Ihandle*)IupGetAttribute(canvas, "CONFIG");
      IupConfigDialogClosed(config, dlg, "ImageEditorDialog");
    }
    return;
  }

  IupSetAttribute(canvas, "IUP_IMAGE", (char*)iup_image);
  IupSetStrAttribute(canvas, "IUP_IMAGE_NAME", name);
  IupSetStrAttribute(canvas, "_IUPLED_FILENAME", filename);

  set_new_image(canvas, image, 0);
}
